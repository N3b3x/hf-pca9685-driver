{"0": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "HF-PCA9685 Driver",
    "content": "Hardware-agnostic C++ driver for the NXP PCA9685 16-channel 12-bit PWM controller . ",
    "url": "/hf-pca9685-driver/development/#hf-pca9685-driver",
    
    "relUrl": "/#hf-pca9685-driver"
  },"1": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üìö Table of Contents",
    "content": ". | Overview | Features | Quick Start | Installation | API Reference | Examples | Documentation | Contributing | License | . ",
    "url": "/hf-pca9685-driver/development/#-table-of-contents",
    
    "relUrl": "/#-table-of-contents"
  },"2": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üì¶ Overview",
    "content": "üìñ üìöüåê Live Complete Documentation - Interactive guides, examples, and step-by-step tutorials . The PCA9685 is a 16-channel, 12-bit PWM controller from NXP Semiconductors that communicates via I¬≤C. It provides independent PWM control for up to 16 outputs with 12-bit resolution (4096 steps), making it ideal for driving LEDs, servos, and other PWM-controlled devices. The chip features an internal 25 MHz oscillator, configurable PWM frequency from 24 Hz to 1526 Hz, and supports daisy-chaining multiple devices for up to 992 PWM outputs. This driver provides a hardware-agnostic C++ interface that abstracts all register-level operations, requiring only an implementation of the I2cInterface for your platform. The driver uses the CRTP (Curiously Recurring Template Pattern) for zero-overhead hardware abstraction, making it suitable for resource-constrained embedded systems. ",
    "url": "/hf-pca9685-driver/development/#-overview",
    
    "relUrl": "/#-overview"
  },"3": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "‚ú® Features",
    "content": ". | ‚úÖ 16 Independent PWM Channels: Each with 12-bit resolution (0-4095) | ‚úÖ Configurable Frequency: 24 Hz to 1526 Hz (typical range) | ‚úÖ Hardware Agnostic: CRTP-based I2C interface for platform independence | ‚úÖ Modern C++: C++11 compatible with template-based design | ‚úÖ Zero Overhead: CRTP design for compile-time polymorphism | ‚úÖ Error Reporting: Bitmask error flags (uint16_t) via GetErrorFlags() / ClearErrorFlags() | ‚úÖ Duty Cycle Control: High-level SetDuty() method for easy 0.0-1.0 control | ‚úÖ Bulk Operations: SetAllPwm() for simultaneous channel updates | ‚úÖ Power Management: Sleep() / Wake() via MODE1 SLEEP bit | ‚úÖ Output Modes: SetOutputInvert(), SetOutputDriverMode() (totem-pole/open-drain) | ‚úÖ Full ON/OFF: SetChannelFullOn() / SetChannelFullOff() without PWM | ‚úÖ Retry Logic: Configurable I2C retry count via SetRetries() | . ",
    "url": "/hf-pca9685-driver/development/#-features",
    
    "relUrl": "/#-features"
  },"4": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üöÄ Quick Start",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 . | #include \"pca9685.hpp\" // 1. Implement the I2C interface (see platform_integration.md) class MyI2c : public pca9685::I2cInterface&lt;MyI2c&gt; { public: bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept; bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept; bool EnsureInitialized() noexcept; }; // 2. Create driver instance MyI2c i2c; pca9685::PCA9685&lt;MyI2c&gt; pwm(&amp;i2c, 0x40); // 0x40 is default I2C address // 3. Initialize and use pwm.Reset(); pwm.SetPwmFreq(50.0f); // 50 Hz for servos pwm.SetDuty(0, 0.075f); // Channel 0, 7.5% duty (1.5ms pulse for servo) . | . For detailed setup, see Installation and Quick Start Guide. ",
    "url": "/hf-pca9685-driver/development/#-quick-start",
    
    "relUrl": "/#-quick-start"
  },"5": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üîß Installation",
    "content": ". | Clone or copy the driver files into your project | Implement the I2C interface for your platform (see Platform Integration) | Include the header in your code: | 1 . | #include \"pca9685.hpp\" . | . | Compile with a C++11 or newer compiler | . For detailed installation instructions, see docs/installation.md. ",
    "url": "/hf-pca9685-driver/development/#-installation",
    
    "relUrl": "/#-installation"
  },"6": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üìñ API Reference",
    "content": "| Method | Description | . | Reset() | Reset device to power-on default state | . | SetPwmFreq(float freq_hz) | Set PWM frequency (24-1526 Hz) | . | SetPwm(uint8_t channel, uint16_t on, uint16_t off) | Set PWM timing for a channel | . | SetDuty(uint8_t channel, float duty) | Set duty cycle (0.0-1.0) for a channel | . | SetAllPwm(uint16_t on, uint16_t off) | Set all channels simultaneously | . | SetChannelFullOn(uint8_t channel) | Set channel fully on (no PWM) | . | SetChannelFullOff(uint8_t channel) | Set channel fully off (no PWM) | . | Sleep() / Wake() | Power management via MODE1 SLEEP bit | . | SetOutputInvert(bool invert) | Set MODE2 INVRT bit | . | SetOutputDriverMode(bool totem_pole) | Set MODE2 OUTDRV bit (true=totem-pole, false=open-drain) | . | SetRetries(int retries) | Configure I2C retry count | . | GetLastError() | Get the last error code (convenience accessor) | . | GetErrorFlags() | Get all error flags as uint16_t bitmask | . | ClearErrorFlags(uint16_t mask) | Clear specific error flags | . | GetPrescale(uint8_t &amp;prescale) | Get current prescale value | . For complete API documentation with source code links, see docs/api_reference.md. ",
    "url": "/hf-pca9685-driver/development/#-api-reference",
    
    "relUrl": "/#-api-reference"
  },"7": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üìä Examples",
    "content": "For ESP32 examples, see the examples/esp32 directory. Additional examples for other platforms are available in the examples directory. Detailed example walkthroughs are available in docs/examples.md. ",
    "url": "/hf-pca9685-driver/development/#-examples",
    
    "relUrl": "/#-examples"
  },"8": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üìö Documentation",
    "content": "For complete documentation, see the docs directory. ",
    "url": "/hf-pca9685-driver/development/#-documentation",
    
    "relUrl": "/#-documentation"
  },"9": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "ü§ù Contributing",
    "content": "Pull requests and suggestions are welcome! Please follow the existing code style and include tests for new features. ",
    "url": "/hf-pca9685-driver/development/#-contributing",
    
    "relUrl": "/#-contributing"
  },"10": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üìÑ License",
    "content": "This project is licensed under the GNU General Public License v3.0. See the LICENSE file for details. ",
    "url": "/hf-pca9685-driver/development/#-license",
    
    "relUrl": "/#-license"
  },"11": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "HardFOC PCA9685 Driver",
    "content": " ",
    "url": "/hf-pca9685-driver/development/",
    
    "relUrl": "/"
  },"12": {
    "doc": "üìñ API Reference",
    "title": "API Reference",
    "content": "Complete reference documentation for all public methods and types in the PCA9685 driver. ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#api-reference",
    
    "relUrl": "/docs/api_reference/#api-reference"
  },"13": {
    "doc": "üìñ API Reference",
    "title": "Source Code",
    "content": ". | Main Header: inc/pca9685.hpp | I2C Interface: inc/pca9685_i2c_interface.hpp | Implementation: src/pca9685.ipp (template implementation, included by header) | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#source-code",
    
    "relUrl": "/docs/api_reference/#source-code"
  },"14": {
    "doc": "üìñ API Reference",
    "title": "Core Class",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#core-class",
    
    "relUrl": "/docs/api_reference/#core-class"
  },"15": {
    "doc": "üìñ API Reference",
    "title": "PCA9685&lt;I2cType&gt;",
    "content": "Main driver class for interfacing with the PCA9685 PWM controller. Template Parameter: I2cType - Your I2C interface implementation (must inherit from pca9685::I2cInterface&lt;I2cType&gt;) . Location: inc/pca9685.hpp . Constructor: . | 1 . | PCA9685(I2cType* bus, uint8_t address); . | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#pca9685i2ctype",
    
    "relUrl": "/docs/api_reference/#pca9685i2ctype"
  },"16": {
    "doc": "üìñ API Reference",
    "title": "Methods",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#methods",
    
    "relUrl": "/docs/api_reference/#methods"
  },"17": {
    "doc": "üìñ API Reference",
    "title": "Initialization",
    "content": "| Method | Signature | Description | . | EnsureInitialized() | bool EnsureInitialized() noexcept | Lazy initialization - ensures bus and device are ready | . | IsInitialized() | bool IsInitialized() const noexcept | Check if driver has been initialized | . | Reset() | bool Reset() noexcept | Reset device to power-on default state | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#initialization",
    
    "relUrl": "/docs/api_reference/#initialization"
  },"18": {
    "doc": "üìñ API Reference",
    "title": "Frequency Control",
    "content": "| Method | Signature | Description | . | SetPwmFreq() | bool SetPwmFreq(float freq_hz) noexcept | Set PWM frequency for all channels (24-1526 Hz) | . | GetPrescale() | bool GetPrescale(uint8_t&amp; prescale) noexcept | Get current prescale register value | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#frequency-control",
    
    "relUrl": "/docs/api_reference/#frequency-control"
  },"19": {
    "doc": "üìñ API Reference",
    "title": "PWM Control",
    "content": "| Method | Signature | Description | . | SetPwm() | bool SetPwm(uint8_t channel, uint16_t on_time, uint16_t off_time) noexcept | Set PWM on/off time for a channel | . | SetDuty() | bool SetDuty(uint8_t channel, float duty) noexcept | Set duty cycle (0.0-1.0) for a channel | . | SetAllPwm() | bool SetAllPwm(uint16_t on_time, uint16_t off_time) noexcept | Set all channels to the same PWM value | . | SetChannelFullOn() | bool SetChannelFullOn(uint8_t channel) noexcept | Set channel to fully ON (100% duty) | . | SetChannelFullOff() | bool SetChannelFullOff(uint8_t channel) noexcept | Set channel to fully OFF (0% duty) | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#pwm-control",
    
    "relUrl": "/docs/api_reference/#pwm-control"
  },"20": {
    "doc": "üìñ API Reference",
    "title": "Power Management",
    "content": "| Method | Signature | Description | . | Sleep() | bool Sleep() noexcept | Put PCA9685 into low-power sleep mode | . | Wake() | bool Wake() noexcept | Wake PCA9685 from sleep mode | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#power-management",
    
    "relUrl": "/docs/api_reference/#power-management"
  },"21": {
    "doc": "üìñ API Reference",
    "title": "Output Configuration",
    "content": "| Method | Signature | Description | . | SetOutputInvert() | bool SetOutputInvert(bool invert) noexcept | Set output polarity inversion | . | SetOutputDriverMode() | bool SetOutputDriverMode(bool totem_pole) noexcept | Set totem-pole or open-drain mode | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#output-configuration",
    
    "relUrl": "/docs/api_reference/#output-configuration"
  },"22": {
    "doc": "üìñ API Reference",
    "title": "Error Handling",
    "content": "| Method | Signature | Description | . | GetLastError() | Error GetLastError() const noexcept | Get last error code (single-error convenience) | . | GetErrorFlags() | uint16_t GetErrorFlags() const noexcept | Get accumulated error flags (bitmask) | . | HasError() | bool HasError(Error e) const noexcept | Check if a specific error flag is set | . | HasAnyError() | bool HasAnyError() const noexcept | Check if any error flag is set | . | ClearError() | void ClearError(Error e) noexcept | Clear a single error flag | . | ClearErrorFlags() | void ClearErrorFlags(uint16_t mask = 0xFFFF) noexcept | Clear error flags by bitmask | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#error-handling",
    
    "relUrl": "/docs/api_reference/#error-handling"
  },"23": {
    "doc": "üìñ API Reference",
    "title": "Configuration",
    "content": "| Method | Signature | Description | . | SetRetries() | void SetRetries(int retries) noexcept | Set I2C retry count for register operations | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#configuration",
    
    "relUrl": "/docs/api_reference/#configuration"
  },"24": {
    "doc": "üìñ API Reference",
    "title": "Types",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#types",
    
    "relUrl": "/docs/api_reference/#types"
  },"25": {
    "doc": "üìñ API Reference",
    "title": "Enumerations",
    "content": "| Type | Values | Location | . | Error | None, I2cWrite, I2cRead, InvalidParam, DeviceNotFound, NotInitialized, OutOfRange | inc/pca9685.hpp | . | Register | MODE1, MODE2, LED0_ON_L, LED0_OFF_L, PRE_SCALE, etc. | inc/pca9685.hpp | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#enumerations",
    
    "relUrl": "/docs/api_reference/#enumerations"
  },"26": {
    "doc": "üìñ API Reference",
    "title": "Constants",
    "content": "| Constant | Value | Description | . | MAX_CHANNELS_ | 16 | Maximum number of PWM channels | . | MAX_PWM_ | 4095 | Maximum PWM value (12-bit) | . | OSC_FREQ_ | 25000000 | Internal oscillator frequency (25 MHz) | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#constants",
    
    "relUrl": "/docs/api_reference/#constants"
  },"27": {
    "doc": "üìñ API Reference",
    "title": "I2C Interface",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#i2c-interface",
    
    "relUrl": "/docs/api_reference/#i2c-interface"
  },"28": {
    "doc": "üìñ API Reference",
    "title": "I2cInterface&lt;Derived&gt; (CRTP)",
    "content": "Hardware-agnostic I2C interface using the Curiously Recurring Template Pattern. Location: inc/pca9685_i2c_interface.hpp . | Method | Signature | Description | . | Write() | bool Write(uint8_t addr, uint8_t reg, const uint8_t* data, size_t len) noexcept | Write bytes to a device register | . | Read() | bool Read(uint8_t addr, uint8_t reg, uint8_t* data, size_t len) noexcept | Read bytes from a device register | . | EnsureInitialized() | bool EnsureInitialized() noexcept | Ensure I2C bus is initialized and ready | . Navigation ‚¨ÖÔ∏è Configuration | Next: Examples ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#i2cinterfacederived-crtp",
    
    "relUrl": "/docs/api_reference/#i2cinterfacederived-crtp"
  },"29": {
    "doc": "üìñ API Reference",
    "title": "üìñ API Reference",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/",
    
    "relUrl": "/docs/api_reference/"
  },"30": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Configuration",
    "content": "This guide covers all configuration options available for the PCA9685 driver. ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#configuration",
    
    "relUrl": "/docs/configuration/#configuration"
  },"31": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "I2C Address Configuration",
    "content": "The PCA9685 I2C address is configured via hardware pins A0-A5. Each pin represents one bit of the 6-bit address field. | Pin | Address Bit | Description | . | A0 | Bit 0 | Least significant address bit | . | A1 | Bit 1 | ¬† | . | A2 | Bit 2 | ¬† | . | A3 | Bit 3 | ¬† | . | A4 | Bit 4 | ¬† | . | A5 | Bit 5 | Most significant address bit | . Default I2C address: 0x40 (all address pins to GND) . Address Range: 0x40 to 0x7F (7-bit I2C addresses) . Example: To set address 0x41, connect A0 to VDD and A1-A5 to GND. ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#i2c-address-configuration",
    
    "relUrl": "/docs/configuration/#i2c-address-configuration"
  },"32": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "PWM Frequency Configuration",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#pwm-frequency-configuration",
    
    "relUrl": "/docs/configuration/#pwm-frequency-configuration"
  },"33": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Setting Frequency",
    "content": "Use the SetPwmFreq() method to configure the PWM frequency: . | 1 2 . | pwm.SetPwmFreq(50.0f); // 50 Hz for servos pwm.SetPwmFreq(1000.0f); // 1 kHz for LEDs . | . Valid Range: 24 Hz to 1526 Hz (typical) . Location: src/pca9685.cpp#L46 . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#setting-frequency",
    
    "relUrl": "/docs/configuration/#setting-frequency"
  },"34": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Frequency Calculation",
    "content": "The driver automatically calculates the prescale value using the formula: . | 1 . | prescale = round(25,000,000 / (4096 * freq_hz)) - 1 . | . Where: . | 25,000,000 is the internal oscillator frequency (25 MHz) | 4096 is the PWM resolution (12 bits) | freq_hz is the desired frequency | . Implementation: src/pca9685.cpp#L168 . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#frequency-calculation",
    
    "relUrl": "/docs/configuration/#frequency-calculation"
  },"35": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Common Frequencies",
    "content": "| Application | Frequency | Prescale (approx) | . | Servos | 50 Hz | 121 | . | LEDs (smooth dimming) | 1000 Hz | 5 | . | Motors | 100-500 Hz | 11-61 | . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#common-frequencies",
    
    "relUrl": "/docs/configuration/#common-frequencies"
  },"36": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Channel Configuration",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#channel-configuration",
    
    "relUrl": "/docs/configuration/#channel-configuration"
  },"37": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Individual Channel Control",
    "content": "Set PWM for a single channel: . | 1 2 3 4 5 . | // Set channel 0: on at tick 0, off at tick 2048 (50% duty) pwm.SetPwm(0, 0, 2048); // Set duty cycle (0.0 = off, 1.0 = fully on) pwm.SetDuty(0, 0.5f); // 50% duty . | . Channel Range: 0-15 (16 channels total) . PWM Value Range: 0-4095 (12-bit resolution) . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#individual-channel-control",
    
    "relUrl": "/docs/configuration/#individual-channel-control"
  },"38": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Bulk Channel Control",
    "content": "Set all channels simultaneously: . | 1 2 . | // Set all channels to same PWM value pwm.SetAllPwm(0, 2048); // All channels at 50% duty . | . Use Case: Synchronized control of all outputs . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#bulk-channel-control",
    
    "relUrl": "/docs/configuration/#bulk-channel-control"
  },"39": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Register Map Reference",
    "content": "The driver abstracts register access, but understanding the register map helps with advanced usage: . | Register | Address | Purpose | . | MODE1 | 0x00 | Main configuration (reset, sleep, auto-increment) | . | MODE2 | 0x01 | Output configuration (open-drain, totem-pole, inversion) | . | SUBADR1-3 | 0x02-0x04 | Subaddress registers | . | ALLCALLADR | 0x05 | All-call I2C address | . | LED0_ON_L | 0x06 | Channel 0 ON time (low byte) | . | LED0_ON_H | 0x07 | Channel 0 ON time (high byte) | . | LED0_OFF_L | 0x08 | Channel 0 OFF time (low byte) | . | LED0_OFF_H | 0x09 | Channel 0 OFF time (high byte) | . | ‚Ä¶ | ‚Ä¶ | Channels 1-15 follow sequentially | . | ALL_LED_ON_L | 0xFA | All channels ON time (low byte) | . | ALL_LED_ON_H | 0xFB | All channels ON time (high byte) | . | ALL_LED_OFF_L | 0xFC | All channels OFF time (low byte) | . | ALL_LED_OFF_H | 0xFD | All channels OFF time (high byte) | . | PRE_SCALE | 0xFE | PWM frequency prescaler | . | TESTMODE | 0xFF | Test mode register | . Register Definitions: inc/pca9685.hpp#L139 . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#register-map-reference",
    
    "relUrl": "/docs/configuration/#register-map-reference"
  },"40": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Advanced Features",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#advanced-features",
    
    "relUrl": "/docs/configuration/#advanced-features"
  },"41": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Output Enable (OE) Pin",
    "content": "The OE pin provides hardware control over all outputs: . | HIGH: All outputs disabled (high-impedance) | LOW/Floating: All outputs enabled | . Note: The driver does not control the OE pin. You must handle it externally via GPIO if needed. ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#output-enable-oe-pin",
    
    "relUrl": "/docs/configuration/#output-enable-oe-pin"
  },"42": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Sleep Mode",
    "content": "The chip supports sleep mode for power saving. The driver handles sleep mode automatically when changing frequency (see SetPwmFreq() implementation). ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#sleep-mode",
    
    "relUrl": "/docs/configuration/#sleep-mode"
  },"43": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Auto-Increment",
    "content": "The chip supports auto-increment for efficient register access. The driver uses this feature internally for multi-byte writes. ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#auto-increment",
    
    "relUrl": "/docs/configuration/#auto-increment"
  },"44": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Runtime Configuration",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#runtime-configuration",
    
    "relUrl": "/docs/configuration/#runtime-configuration"
  },"45": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Initialization Sequence",
    "content": ". | Reset: Call Reset() to put device in known state | Set Frequency: Call SetPwmFreq() before setting channels | Configure Channels: Use SetPwm() or SetDuty() to control outputs | . Example: . | 1 2 3 . | pwm.Reset(); // Initialize pwm.SetPwmFreq(50.0f); // Set frequency pwm.SetDuty(0, 0.5f); // Configure channel . | . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#initialization-sequence",
    
    "relUrl": "/docs/configuration/#initialization-sequence"
  },"46": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Recommended Settings",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#recommended-settings",
    
    "relUrl": "/docs/configuration/#recommended-settings"
  },"47": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "For Servo Control",
    "content": "| 1 2 3 4 5 . | pwm.Reset(); pwm.SetPwmFreq(50.0f); // Standard servo frequency // Set servo to center position (1.5ms pulse) pwm.SetDuty(0, 0.075f); // 7.5% duty = 1.5ms / 20ms . | . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#for-servo-control",
    
    "relUrl": "/docs/configuration/#for-servo-control"
  },"48": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "For LED Dimming",
    "content": "| 1 2 3 4 5 6 7 8 . | pwm.Reset(); pwm.SetPwmFreq(1000.0f); // High frequency for smooth dimming // Fade LED on channel 0 for (float duty = 0.0f; duty &lt;= 1.0f; duty += 0.01f) { pwm.SetDuty(0, duty); delay(10); } . | . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#for-led-dimming",
    
    "relUrl": "/docs/configuration/#for-led-dimming"
  },"49": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "For Motor Control",
    "content": "| 1 2 3 4 5 . | pwm.Reset(); pwm.SetPwmFreq(200.0f); // Moderate frequency for motors // Set motor speed pwm.SetDuty(0, 0.75f); // 75% speed . | . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#for-motor-control",
    
    "relUrl": "/docs/configuration/#for-motor-control"
  },"50": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Next Steps",
    "content": ". | See Examples for configuration examples | Review API Reference for all configuration methods | Check Troubleshooting for configuration issues | . Navigation ‚¨ÖÔ∏è Platform Integration | Next: API Reference ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#next-steps",
    
    "relUrl": "/docs/configuration/#next-steps"
  },"51": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "‚öôÔ∏è Configuration",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/configuration/",
    
    "relUrl": "/docs/configuration/"
  },"52": {
    "doc": "üí° Examples",
    "title": "Examples",
    "content": "This guide provides complete, working examples demonstrating various use cases for the PCA9685 driver. ",
    "url": "/hf-pca9685-driver/development/docs/examples/#examples",
    
    "relUrl": "/docs/examples/#examples"
  },"53": {
    "doc": "üí° Examples",
    "title": "Example 1: Basic Servo Control",
    "content": "This example shows how to control a standard servo motor using the PCA9685. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 . | #include \"pca9685.hpp\" #include \"driver/i2c.h\" // ESP32 I2C implementation class Esp32I2cBus : public pca9685::I2cInterface&lt;Esp32I2cBus&gt; { public: bool EnsureInitialized() noexcept { return true; } bool Write(uint8_t addr, uint8_t reg, const uint8_t* data, size_t len) noexcept { i2c_cmd_handle_t cmd = i2c_cmd_link_create(); i2c_master_start(cmd); i2c_master_write_byte(cmd, (addr &lt;&lt; 1) | I2C_MASTER_WRITE, true); i2c_master_write_byte(cmd, reg, true); i2c_master_write(cmd, (uint8_t*)data, len, true); i2c_master_stop(cmd); esp_err_t ret = i2c_master_cmd_begin(I2C_NUM_0, cmd, 1000 / portTICK_PERIOD_MS); i2c_cmd_link_delete(cmd); return ret == ESP_OK; } bool Read(uint8_t addr, uint8_t reg, uint8_t* data, size_t len) noexcept { i2c_cmd_handle_t cmd = i2c_cmd_link_create(); i2c_master_start(cmd); i2c_master_write_byte(cmd, (addr &lt;&lt; 1) | I2C_MASTER_WRITE, true); i2c_master_write_byte(cmd, reg, true); i2c_master_start(cmd); i2c_master_write_byte(cmd, (addr &lt;&lt; 1) | I2C_MASTER_READ, true); i2c_master_read(cmd, data, len, I2C_MASTER_LAST_NACK); i2c_master_stop(cmd); esp_err_t ret = i2c_master_cmd_begin(I2C_NUM_0, cmd, 1000 / portTICK_PERIOD_MS); i2c_cmd_link_delete(cmd); return ret == ESP_OK; } }; extern \"C\" void app_main() { // Initialize I2C (not shown - use your platform's I2C init) Esp32I2cBus i2c; pca9685::PCA9685&lt;Esp32I2cBus&gt; pwm(&amp;i2c, 0x40); // Initialize if (!pwm.Reset()) { printf(\"Failed to initialize PCA9685!\\n\"); return; } // Set frequency for servos (50 Hz) pwm.SetPwmFreq(50.0f); // Move servo to center position (1.5ms pulse = 7.5% duty at 50 Hz) pwm.SetDuty(0, 0.075f); // Move servo to 90 degrees (2.0ms pulse = 10% duty) pwm.SetDuty(0, 0.10f); // Move servo to 0 degrees (1.0ms pulse = 5% duty) pwm.SetDuty(0, 0.05f); printf(\"Servo control example complete.\\n\"); } . | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#example-1-basic-servo-control",
    
    "relUrl": "/docs/examples/#example-1-basic-servo-control"
  },"54": {
    "doc": "üí° Examples",
    "title": "Explanation",
    "content": ". | I2C Interface: Implement I2cInterface for your platform (ESP32 example shown) | Initialization: Call Reset() to initialize the device | Frequency: Set 50 Hz for standard servos (20ms period) | Duty Cycle: Use SetDuty() with values 0.05-0.10 for typical servo range . | 0.05 = 1.0ms pulse (0 degrees) | 0.075 = 1.5ms pulse (center/90 degrees) | 0.10 = 2.0ms pulse (180 degrees) | . | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#explanation",
    
    "relUrl": "/docs/examples/#explanation"
  },"55": {
    "doc": "üí° Examples",
    "title": "Expected Output",
    "content": "The servo should move to different positions as the duty cycle changes. ",
    "url": "/hf-pca9685-driver/development/docs/examples/#expected-output",
    
    "relUrl": "/docs/examples/#expected-output"
  },"56": {
    "doc": "üí° Examples",
    "title": "Example 2: LED Dimming",
    "content": "This example demonstrates smooth LED dimming using PWM. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 . | #include \"pca9685.hpp\" // ... I2C implementation (same as Example 1) ... void fade_led(pca9685::PCA9685&lt;Esp32I2cBus&gt;&amp; pwm, uint8_t channel) { // Set high frequency for smooth dimming (1 kHz) pwm.SetPwmFreq(1000.0f); // Fade in for (float duty = 0.0f; duty &lt;= 1.0f; duty += 0.01f) { pwm.SetDuty(channel, duty); vTaskDelay(pdMS_TO_TICKS(10)); // 10ms delay } // Fade out for (float duty = 1.0f; duty &gt;= 0.0f; duty -= 0.01f) { pwm.SetDuty(channel, duty); vTaskDelay(pdMS_TO_TICKS(10)); } } extern \"C\" void app_main() { Esp32I2cBus i2c; pca9685::PCA9685&lt;Esp32I2cBus&gt; pwm(&amp;i2c, 0x40); pwm.Reset(); // Fade LED on channel 0 fade_led(pwm, 0); } . | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#example-2-led-dimming",
    
    "relUrl": "/docs/examples/#example-2-led-dimming"
  },"57": {
    "doc": "üí° Examples",
    "title": "Explanation",
    "content": ". | High Frequency: Use 1 kHz for smooth LED dimming (avoids visible flicker) | Duty Cycle Sweep: Gradually change duty from 0.0 to 1.0 for fade effect | Timing: Small delays between updates create smooth transitions | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#explanation-1",
    
    "relUrl": "/docs/examples/#explanation-1"
  },"58": {
    "doc": "üí° Examples",
    "title": "Example 3: Multiple Channels",
    "content": "This example shows controlling multiple channels simultaneously. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 . | #include \"pca9685.hpp\" // ... I2C implementation ... extern \"C\" void app_main() { Esp32I2cBus i2c; pca9685::PCA9685&lt;Esp32I2cBus&gt; pwm(&amp;i2c, 0x40); pwm.Reset(); pwm.SetPwmFreq(1000.0f); // 1 kHz for LEDs // Set different duty cycles for different channels pwm.SetDuty(0, 0.25f); // Channel 0: 25% brightness pwm.SetDuty(1, 0.50f); // Channel 1: 50% brightness pwm.SetDuty(2, 0.75f); // Channel 2: 75% brightness pwm.SetDuty(3, 1.0f); // Channel 3: 100% brightness // Set all remaining channels to 50% for (uint8_t ch = 4; ch &lt; 16; ch++) { pwm.SetDuty(ch, 0.5f); } } . | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#example-3-multiple-channels",
    
    "relUrl": "/docs/examples/#example-3-multiple-channels"
  },"59": {
    "doc": "üí° Examples",
    "title": "Explanation",
    "content": "Each channel operates independently. You can set different duty cycles for each of the 16 channels. ",
    "url": "/hf-pca9685-driver/development/docs/examples/#explanation-2",
    
    "relUrl": "/docs/examples/#explanation-2"
  },"60": {
    "doc": "üí° Examples",
    "title": "Example 4: Error Handling",
    "content": "This example demonstrates proper error handling using the bitmask error model. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 . | #include \"pca9685.hpp\" // ... I2C implementation ... extern \"C\" void app_main() { Esp32I2cBus i2c; pca9685::PCA9685&lt;Esp32I2cBus&gt; pwm(&amp;i2c, 0x40); // Initialize with error checking if (!pwm.Reset()) { // Use GetErrorFlags() for bitmask-based error checking (uint16_t) uint16_t flags = pwm.GetErrorFlags(); printf(\"Reset failed: error flags 0x%04X\\n\", flags); // Or use GetLastError() as a convenience accessor auto error = pwm.GetLastError(); printf(\"Reset failed: error code %d\\n\", static_cast&lt;int&gt;(error)); return; } // Set frequency with validation if (!pwm.SetPwmFreq(50.0f)) { uint16_t flags = pwm.GetErrorFlags(); if (flags &amp; static_cast&lt;uint16_t&gt;(pca9685::PCA9685&lt;Esp32I2cBus&gt;::Error::OutOfRange)) { printf(\"Frequency out of range!\\n\"); } if (flags &amp; static_cast&lt;uint16_t&gt;(pca9685::PCA9685&lt;Esp32I2cBus&gt;::Error::I2cWrite)) { printf(\"I2C write failed!\\n\"); } pwm.ClearErrorFlags(flags); // Clear after handling return; } // Set channel with error checking if (!pwm.SetDuty(0, 0.5f)) { uint16_t flags = pwm.GetErrorFlags(); printf(\"SetDuty failed: error flags 0x%04X\\n\", flags); pwm.ClearErrorFlags(flags); } } . | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#example-4-error-handling",
    
    "relUrl": "/docs/examples/#example-4-error-handling"
  },"61": {
    "doc": "üí° Examples",
    "title": "Explanation",
    "content": "Error flags are now uint16_t bitmask values: . | I2cWrite = 1&lt;&lt;0, I2cRead = 1&lt;&lt;1, InvalidParam = 1&lt;&lt;2 | DeviceNotFound = 1&lt;&lt;3, NotInitialized = 1&lt;&lt;4, OutOfRange = 1&lt;&lt;5 | . Use GetErrorFlags() to retrieve all accumulated error flags, and ClearErrorFlags(mask) to clear them after handling. The convenience accessor GetLastError() still works for simple cases. Multiple error conditions can be set simultaneously since flags are a bitmask. ",
    "url": "/hf-pca9685-driver/development/docs/examples/#explanation-3",
    
    "relUrl": "/docs/examples/#explanation-3"
  },"62": {
    "doc": "üí° Examples",
    "title": "Example 5: Bulk Channel Update",
    "content": "This example shows efficient bulk updates using SetAllPwm(). | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 . | #include \"pca9685.hpp\" // ... I2C implementation ... extern \"C\" void app_main() { Esp32I2cBus i2c; pca9685::PCA9685&lt;Esp32I2cBus&gt; pwm(&amp;i2c, 0x40); pwm.Reset(); pwm.SetPwmFreq(1000.0f); // Turn all channels on to 50% simultaneously pwm.SetAllPwm(0, 2048); // Turn all channels off pwm.SetAllPwm(0, 0); // Turn all channels fully on pwm.SetAllPwm(0, 4095); } . | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#example-5-bulk-channel-update",
    
    "relUrl": "/docs/examples/#example-5-bulk-channel-update"
  },"63": {
    "doc": "üí° Examples",
    "title": "Explanation",
    "content": "SetAllPwm() is more efficient than calling SetPwm() 16 times. It writes to the ALL_LED registers, updating all channels in a single I2C transaction. ",
    "url": "/hf-pca9685-driver/development/docs/examples/#explanation-4",
    
    "relUrl": "/docs/examples/#explanation-4"
  },"64": {
    "doc": "üí° Examples",
    "title": "Example 6: Power Management and Output Modes",
    "content": "This example demonstrates the power management and output configuration features. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 . | #include \"pca9685.hpp\" // ... I2C implementation ... extern \"C\" void app_main() { Esp32I2cBus i2c; pca9685::PCA9685&lt;Esp32I2cBus&gt; pwm(&amp;i2c, 0x40); pwm.Reset(); pwm.SetPwmFreq(1000.0f); // Configure retry count for I2C operations (default is 1 retry) pwm.SetRetries(3); // Configure output driver mode (true = totem-pole, false = open-drain) pwm.SetOutputDriverMode(true); // Optionally invert outputs pwm.SetOutputInvert(false); // Set some channels pwm.SetDuty(0, 0.5f); // Use full ON/OFF without PWM pwm.SetChannelFullOn(1); // Channel 1 fully on pwm.SetChannelFullOff(2); // Channel 2 fully off // Power management: put device to sleep pwm.Sleep(); // ... device is in low-power mode ... // Wake up and resume pwm.Wake(); // Outputs resume from where they were } . | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#example-6-power-management-and-output-modes",
    
    "relUrl": "/docs/examples/#example-6-power-management-and-output-modes"
  },"65": {
    "doc": "üí° Examples",
    "title": "Explanation",
    "content": ". | SetRetries(): Configures how many times I2C operations are retried on failure (default 1) | SetOutputDriverMode(): Selects totem-pole (true) or open-drain (false) output via MODE2 OUTDRV bit | SetOutputInvert(): Inverts output logic via MODE2 INVRT bit | SetChannelFullOn() / SetChannelFullOff(): Sets a channel fully on or off without PWM | Sleep() / Wake(): Controls the MODE1 SLEEP bit for low-power mode | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#explanation-5",
    
    "relUrl": "/docs/examples/#explanation-5"
  },"66": {
    "doc": "üí° Examples",
    "title": "Running the Examples",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/examples/#running-the-examples",
    
    "relUrl": "/docs/examples/#running-the-examples"
  },"67": {
    "doc": "üí° Examples",
    "title": "ESP32",
    "content": "The examples are available in the examples/esp32 directory. | 1 2 . | cd examples/esp32 idf.py build flash monitor . | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#esp32",
    
    "relUrl": "/docs/examples/#esp32"
  },"68": {
    "doc": "üí° Examples",
    "title": "Other Platforms",
    "content": "Adapt the I2C interface implementation for your platform (see Platform Integration) and compile with your platform‚Äôs toolchain. ",
    "url": "/hf-pca9685-driver/development/docs/examples/#other-platforms",
    
    "relUrl": "/docs/examples/#other-platforms"
  },"69": {
    "doc": "üí° Examples",
    "title": "Next Steps",
    "content": ". | Review the API Reference for method details | Check Troubleshooting if you encounter issues | Explore the examples directory for more examples | . Navigation ‚¨ÖÔ∏è API Reference | Next: Troubleshooting ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#next-steps",
    
    "relUrl": "/docs/examples/#next-steps"
  },"70": {
    "doc": "üí° Examples",
    "title": "üí° Examples",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/examples/",
    
    "relUrl": "/docs/examples/"
  },"71": {
    "doc": "üîå Hardware Setup",
    "title": "Hardware Setup",
    "content": "This guide covers the physical connections and hardware requirements for the PCA9685 chip. ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#hardware-setup",
    
    "relUrl": "/docs/hardware_setup/#hardware-setup"
  },"72": {
    "doc": "üîå Hardware Setup",
    "title": "Pin Connections",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#pin-connections",
    
    "relUrl": "/docs/hardware_setup/#pin-connections"
  },"73": {
    "doc": "üîå Hardware Setup",
    "title": "Basic I2C Connections",
    "content": "| 1 2 3 4 5 6 . | MCU PCA9685 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ VDD GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ GND SCL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SCL (with 4.7kŒ© pull-up to 3.3V) SDA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SDA (with 4.7kŒ© pull-up to 3.3V) . | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#basic-i2c-connections",
    
    "relUrl": "/docs/hardware_setup/#basic-i2c-connections"
  },"74": {
    "doc": "üîå Hardware Setup",
    "title": "Pin Descriptions",
    "content": "| Pin | Name | Description | Required | . | VDD | Power | 2.3V to 5.5V power supply (typically 3.3V or 5V) | Yes | . | GND | Ground | Ground reference | Yes | . | SCL | Clock | I2C clock line | Yes | . | SDA | Data | I2C data line | Yes | . | OE | Output Enable | Active-low output enable (optional) | No | . | A0-A5 | Address | I2C address selection pins | No (for single device) | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#pin-descriptions",
    
    "relUrl": "/docs/hardware_setup/#pin-descriptions"
  },"75": {
    "doc": "üîå Hardware Setup",
    "title": "Output Channels",
    "content": "The PCA9685 provides 16 PWM output channels (OUT0-OUT15). Each channel can drive: . | LEDs (with current-limiting resistors) | Servos (typically 5V servos) | Other PWM-controlled devices | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#output-channels",
    
    "relUrl": "/docs/hardware_setup/#output-channels"
  },"76": {
    "doc": "üîå Hardware Setup",
    "title": "Power Requirements",
    "content": ". | Supply Voltage: 2.3V to 5.5V (3.3V or 5V typical) | Current Consumption: . | Active: ~10 mA typical | Sleep mode: &lt; 1 ¬µA | . | Power Supply: Stable, low-noise supply recommended | Decoupling: 100 nF ceramic capacitor close to VDD pin recommended | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#power-requirements",
    
    "relUrl": "/docs/hardware_setup/#power-requirements"
  },"77": {
    "doc": "üîå Hardware Setup",
    "title": "I2C Configuration",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#i2c-configuration",
    
    "relUrl": "/docs/hardware_setup/#i2c-configuration"
  },"78": {
    "doc": "üîå Hardware Setup",
    "title": "Address Configuration",
    "content": "The PCA9685 I2C address is determined by pins A0-A5: . | A5 | A4 | A3 | A2 | A1 | A0 | I2C Address (7-bit) | . | 0 | 0 | 0 | 0 | 0 | 0 | 0x40 (default) | . | 0 | 0 | 0 | 0 | 0 | 1 | 0x41 | . | ‚Ä¶ | ‚Ä¶ | ‚Ä¶ | ‚Ä¶ | ‚Ä¶ | ‚Ä¶ | ‚Ä¶ | . | 1 | 1 | 1 | 1 | 1 | 1 | 0x7F | . Default: All address pins to GND = 0x40 (used in examples) . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#address-configuration",
    
    "relUrl": "/docs/hardware_setup/#address-configuration"
  },"79": {
    "doc": "üîå Hardware Setup",
    "title": "I2C Bus Configuration",
    "content": ". | Speed: Up to 1 MHz (Fast Mode Plus) . | Standard Mode: 100 kHz | Fast Mode: 400 kHz (most common) | Fast Mode Plus: 1 MHz | . | Pull-up Resistors: 4.7 kŒ© on SCL and SDA (required for I2C) | Bus Voltage: Must match VDD (3.3V or 5V) | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#i2c-bus-configuration",
    
    "relUrl": "/docs/hardware_setup/#i2c-bus-configuration"
  },"80": {
    "doc": "üîå Hardware Setup",
    "title": "Physical Layout Recommendations",
    "content": ". | Trace Length: Keep I2C traces short (&lt; 10 cm recommended for high speeds) | Ground Plane: Use a ground plane for noise reduction | Decoupling: Place 100 nF ceramic capacitor within 1 cm of VDD pin | Routing: Route clock and data lines away from noise sources (switching regulators, motors) | Multiple Devices: When daisy-chaining, use proper bus termination | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#physical-layout-recommendations",
    
    "relUrl": "/docs/hardware_setup/#physical-layout-recommendations"
  },"81": {
    "doc": "üîå Hardware Setup",
    "title": "Example Wiring Diagram",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#example-wiring-diagram",
    
    "relUrl": "/docs/hardware_setup/#example-wiring-diagram"
  },"82": {
    "doc": "üîå Hardware Setup",
    "title": "Single PCA9685",
    "content": "| 1 2 3 4 5 6 7 8 9 . | PCA9685 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ VDD ‚îÇ GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ GND ‚îÇ SCL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SCL ‚îÇ‚îÄ‚îÄ‚îÄ 4.7kŒ© ‚îÄ‚îÄ‚îÄ 3.3V SDA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SDA ‚îÇ‚îÄ‚îÄ‚îÄ 4.7kŒ© ‚îÄ‚îÄ‚îÄ 3.3V ‚îÇ ‚îÇ ‚îÇ OUT0-15 ‚îÇ‚îÄ‚îÄ‚îÄ To LEDs/Servos ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò . | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#single-pca9685",
    
    "relUrl": "/docs/hardware_setup/#single-pca9685"
  },"83": {
    "doc": "üîå Hardware Setup",
    "title": "Multiple PCA9685 Devices (Daisy Chain)",
    "content": "| 1 2 3 4 5 6 7 . | MCU SCL ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ PCA9685 #1 (A0=0, Addr=0x40) SCL ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ PCA9685 #2 (A0=1, Addr=0x41) SCL MCU SDA ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ PCA9685 #1 SDA ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ PCA9685 #2 SDA . | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#multiple-pca9685-devices-daisy-chain",
    
    "relUrl": "/docs/hardware_setup/#multiple-pca9685-devices-daisy-chain"
  },"84": {
    "doc": "üîå Hardware Setup",
    "title": "Output Enable (OE) Pin",
    "content": "The OE pin is an active-low output enable. When pulled HIGH, all outputs are disabled (high-impedance). When pulled LOW or left floating, outputs are enabled. Typical Usage: . | Connect to a GPIO for software control | Leave floating if not needed (internal pull-up enables outputs) | Use for synchronized startup of multiple devices | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#output-enable-oe-pin",
    
    "relUrl": "/docs/hardware_setup/#output-enable-oe-pin"
  },"85": {
    "doc": "üîå Hardware Setup",
    "title": "Next Steps",
    "content": ". | Verify connections with a multimeter | Use an I2C scanner to verify device detection at expected address | Proceed to Quick Start to test the connection | Review Platform Integration for software setup | . Navigation ‚¨ÖÔ∏è Quick Start | Next: Platform Integration ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#next-steps",
    
    "relUrl": "/docs/hardware_setup/#next-steps"
  },"86": {
    "doc": "üîå Hardware Setup",
    "title": "üîå Hardware Setup",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/",
    
    "relUrl": "/docs/hardware_setup/"
  },"87": {
    "doc": "üìö Documentation",
    "title": "HF-PCA9685 Documentation",
    "content": "Welcome! This directory contains step-by-step guides for installing, building, and using the HF-PCA9685 library. ",
    "url": "/hf-pca9685-driver/development/docs/#hf-pca9685-documentation",
    
    "relUrl": "/docs/#hf-pca9685-documentation"
  },"88": {
    "doc": "üìö Documentation",
    "title": "üìö Documentation Structure",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/#-documentation-structure",
    
    "relUrl": "/docs/#-documentation-structure"
  },"89": {
    "doc": "üìö Documentation",
    "title": "Getting Started",
    "content": ". | üõ†Ô∏è Installation ‚Äì Prerequisites and how to obtain the source | ‚ö° Quick Start ‚Äì Minimal working example to get you running | üîå Hardware Setup ‚Äì Wiring diagrams and pin connections | . ",
    "url": "/hf-pca9685-driver/development/docs/#getting-started",
    
    "relUrl": "/docs/#getting-started"
  },"90": {
    "doc": "üìö Documentation",
    "title": "Integration",
    "content": ". | üîß Platform Integration ‚Äì Implement the CRTP bus interface for your platform | ‚öôÔ∏è Configuration ‚Äì Configuration options and settings | . ",
    "url": "/hf-pca9685-driver/development/docs/#integration",
    
    "relUrl": "/docs/#integration"
  },"91": {
    "doc": "üìö Documentation",
    "title": "Reference",
    "content": ". | üìñ API Reference ‚Äì Complete API documentation | üí° Examples ‚Äì Detailed example walkthroughs | . ",
    "url": "/hf-pca9685-driver/development/docs/#reference",
    
    "relUrl": "/docs/#reference"
  },"92": {
    "doc": "üìö Documentation",
    "title": "Troubleshooting",
    "content": ". | üêõ Troubleshooting ‚Äì Common issues and solutions | . ",
    "url": "/hf-pca9685-driver/development/docs/#troubleshooting",
    
    "relUrl": "/docs/#troubleshooting"
  },"93": {
    "doc": "üìö Documentation",
    "title": "üöÄ Quick Start Path",
    "content": "New to PCA9685? Follow this recommended path: . | Start with Installation to prepare your environment | Follow Hardware Setup to wire your hardware | Read Quick Start for a minimal working example | Check Platform Integration to implement the interface | Explore Examples for more advanced usage | . ",
    "url": "/hf-pca9685-driver/development/docs/#-quick-start-path",
    
    "relUrl": "/docs/#-quick-start-path"
  },"94": {
    "doc": "üìö Documentation",
    "title": "üí° Need Help?",
    "content": ". | üêõ Found a bug? Check the Troubleshooting guide | ‚ùì Have questions? Review the API Reference | üìù Want to contribute? See the contributing guidelines in the main README | . Navigation ‚û°Ô∏è Installation . ",
    "url": "/hf-pca9685-driver/development/docs/#-need-help",
    
    "relUrl": "/docs/#-need-help"
  },"95": {
    "doc": "üìö Documentation",
    "title": "üìö Documentation",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/",
    
    "relUrl": "/docs/"
  },"96": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Installation",
    "content": "This guide covers how to obtain, build, and verify the PCA9685 driver library. ",
    "url": "/hf-pca9685-driver/development/docs/installation/#installation",
    
    "relUrl": "/docs/installation/#installation"
  },"97": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Prerequisites",
    "content": "Before installing the driver, ensure you have: . | C++11 Compiler: GCC 4.8+, Clang 3.3+, or MSVC 2013+ | Build System: Make or CMake (optional, for building static library) | Platform SDK: Your platform‚Äôs I2C driver (ESP-IDF, STM32 HAL, Arduino Wire, etc.) | . ",
    "url": "/hf-pca9685-driver/development/docs/installation/#prerequisites",
    
    "relUrl": "/docs/installation/#prerequisites"
  },"98": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Obtaining the Source",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/installation/#obtaining-the-source",
    
    "relUrl": "/docs/installation/#obtaining-the-source"
  },"99": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Option 1: Git Clone",
    "content": "| 1 2 . | git clone https://github.com/N3b3x/hf-pca9685-driver.git cd hf-pca9685-driver . | . ",
    "url": "/hf-pca9685-driver/development/docs/installation/#option-1-git-clone",
    
    "relUrl": "/docs/installation/#option-1-git-clone"
  },"100": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Option 2: Copy Files",
    "content": "Copy the following files into your project: . | 1 2 3 4 . | inc/ ‚îî‚îÄ‚îÄ pca9685.hpp src/ ‚îî‚îÄ‚îÄ pca9685.cpp . | . Note: The driver uses a header-only template design where pca9685.cpp is included by pca9685.hpp. You typically only need to include the header file in your project. ",
    "url": "/hf-pca9685-driver/development/docs/installation/#option-2-copy-files",
    
    "relUrl": "/docs/installation/#option-2-copy-files"
  },"101": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Building the Library",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/installation/#building-the-library",
    
    "relUrl": "/docs/installation/#building-the-library"
  },"102": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Using Make",
    "content": "A simple Makefile is provided: . | 1 . | make . | . This builds build/libpca9685.a which can be linked into your application. ",
    "url": "/hf-pca9685-driver/development/docs/installation/#using-make",
    
    "relUrl": "/docs/installation/#using-make"
  },"103": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Using CMake",
    "content": "| 1 2 . | add_subdirectory(pca9685-driver) target_link_libraries(your_target PRIVATE pca9685) . | . Or manually: . | 1 2 3 4 5 . | add_library(pca9685 STATIC inc/pca9685.hpp src/pca9685.cpp ) target_include_directories(pca9685 PUBLIC inc) . | . ",
    "url": "/hf-pca9685-driver/development/docs/installation/#using-cmake",
    
    "relUrl": "/docs/installation/#using-cmake"
  },"104": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Using ESP-IDF Component",
    "content": "The driver can be used as an ESP-IDF component. See the examples/esp32 directory for component integration examples. ",
    "url": "/hf-pca9685-driver/development/docs/installation/#using-esp-idf-component",
    
    "relUrl": "/docs/installation/#using-esp-idf-component"
  },"105": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Running Unit Tests",
    "content": "The library includes unit tests. To run them: . | 1 2 . | make test ./build/test . | . Expected output: . | 1 . | All tests passed. | . ",
    "url": "/hf-pca9685-driver/development/docs/installation/#running-unit-tests",
    
    "relUrl": "/docs/installation/#running-unit-tests"
  },"106": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Verification",
    "content": "To verify the installation: . | Include the header in a test file: | 1 . | #include \"pca9685.hpp\" . | . | Compile a simple test: | 1 . | g++ -std=c++11 -I inc/ -c src/pca9685.cpp -o test.o . | . | If compilation succeeds, the library is properly installed. | . ",
    "url": "/hf-pca9685-driver/development/docs/installation/#verification",
    
    "relUrl": "/docs/installation/#verification"
  },"107": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Next Steps",
    "content": ". | Follow the Quick Start guide to create your first application | Review Hardware Setup for wiring instructions | Check Platform Integration to implement the I2C interface | . Navigation ‚¨ÖÔ∏è Back to Index | Next: Quick Start ‚û°Ô∏è . ",
    "url": "/hf-pca9685-driver/development/docs/installation/#next-steps",
    
    "relUrl": "/docs/installation/#next-steps"
  },"108": {
    "doc": "üõ†Ô∏è Installation",
    "title": "üõ†Ô∏è Installation",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/installation/",
    
    "relUrl": "/docs/installation/"
  },"109": {
    "doc": "üîß Platform Integration",
    "title": "Platform Integration Guide",
    "content": "This guide explains how to implement the hardware abstraction interface for the PCA9685 driver on your platform. ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#platform-integration-guide",
    
    "relUrl": "/docs/platform_integration/#platform-integration-guide"
  },"110": {
    "doc": "üîß Platform Integration",
    "title": "Understanding CRTP (Curiously Recurring Template Pattern)",
    "content": "The PCA9685 driver uses CRTP (Curiously Recurring Template Pattern) for hardware abstraction. This design choice provides several critical benefits for embedded systems: . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#understanding-crtp-curiously-recurring-template-pattern",
    
    "relUrl": "/docs/platform_integration/#understanding-crtp-curiously-recurring-template-pattern"
  },"111": {
    "doc": "üîß Platform Integration",
    "title": "Why CRTP Instead of Virtual Functions?",
    "content": "1. Zero Runtime Overhead . | Virtual functions: Require a vtable lookup (indirect call) = ~5-10 CPU cycles overhead per call | CRTP: Direct function calls = 0 overhead, compiler can inline | Impact: In time-critical embedded code, this matters significantly | . 2. Compile-Time Polymorphism . | Virtual functions: Runtime dispatch - the compiler cannot optimize across the abstraction boundary | CRTP: Compile-time dispatch - full optimization, dead code elimination, constant propagation | Impact: Smaller code size, faster execution | . 3. Memory Efficiency . | Virtual functions: Each object needs a vtable pointer (4-8 bytes) | CRTP: No vtable pointer needed | Impact: Critical in memory-constrained systems (many MCUs have &lt;64KB RAM) | . 4. Type Safety . | Virtual functions: Runtime errors if method not implemented | CRTP: Compile-time errors if method not implemented | Impact: Catch bugs at compile time, not in the field | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#why-crtp-instead-of-virtual-functions",
    
    "relUrl": "/docs/platform_integration/#why-crtp-instead-of-virtual-functions"
  },"112": {
    "doc": "üîß Platform Integration",
    "title": "How CRTP Works",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 . | // Base template class (from pca9685_i2c_interface.hpp) template &lt;typename Derived&gt; class I2cInterface { public: bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept { // Cast 'this' to Derived* and call the derived implementation return static_cast&lt;Derived*&gt;(this)-&gt;Write(addr, reg, data, len); } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept { return static_cast&lt;Derived*&gt;(this)-&gt;Read(addr, reg, data, len); } bool EnsureInitialized() noexcept { return static_cast&lt;Derived*&gt;(this)-&gt;EnsureInitialized(); } }; // Your implementation class MyI2c : public pca9685::I2cInterface&lt;MyI2c&gt; { public: // This method is called directly (no virtual overhead) bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept { // Your platform-specific I2C code } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept { // Your platform-specific I2C code } bool EnsureInitialized() noexcept { // Lazy-initialize your I2C bus } }; . | . The key insight: static_cast&lt;Derived*&gt;(this) allows the base class to call methods on the derived class at compile time, not runtime. ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#how-crtp-works",
    
    "relUrl": "/docs/platform_integration/#how-crtp-works"
  },"113": {
    "doc": "üîß Platform Integration",
    "title": "Performance Comparison",
    "content": "| Aspect | Virtual Functions | CRTP | . | Function call overhead | ~5-10 cycles | 0 cycles (inlined) | . | Code size | Larger (vtables) | Smaller (optimized) | . | Memory per object | +4-8 bytes (vptr) | 0 bytes | . | Compile-time checks | No | Yes | . | Optimization | Limited | Full | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#performance-comparison",
    
    "relUrl": "/docs/platform_integration/#performance-comparison"
  },"114": {
    "doc": "üîß Platform Integration",
    "title": "Interface Definition",
    "content": "The PCA9685 driver requires you to implement the I2cInterface template: . Location: inc/pca9685.hpp#L57 . | 1 2 3 4 5 6 7 8 . | template &lt;typename Derived&gt; class I2cInterface { public: // Required methods (implement all three) bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept; bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept; bool EnsureInitialized() noexcept; }; . | . Method Requirements: . | Write(): Write len bytes from data to register reg at I2C address addr (7-bit address) | Read(): Read len bytes into data from register reg at I2C address addr (7-bit address) | EnsureInitialized(): Lazy-initialize the I2C bus; return true if ready | All methods return true on success, false on failure (NACK, timeout, etc.) | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#interface-definition",
    
    "relUrl": "/docs/platform_integration/#interface-definition"
  },"115": {
    "doc": "üîß Platform Integration",
    "title": "Implementation Steps",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#implementation-steps",
    
    "relUrl": "/docs/platform_integration/#implementation-steps"
  },"116": {
    "doc": "üîß Platform Integration",
    "title": "Step 1: Create Your Implementation Class",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 . | #include \"pca9685.hpp\" class MyPlatformI2c : public pca9685::I2cInterface&lt;MyPlatformI2c&gt; { private: // Your platform-specific members i2c_handle_t i2c_handle_; bool initialized_ = false; public: // Constructor MyPlatformI2c(i2c_handle_t handle) : i2c_handle_(handle) {} // Implement required methods (NO virtual keyword!) bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept { // Your I2C write implementation return true; } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept { // Your I2C read implementation return true; } bool EnsureInitialized() noexcept { if (initialized_) return true; // Initialize I2C hardware... initialized_ = true; return true; } }; . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#step-1-create-your-implementation-class",
    
    "relUrl": "/docs/platform_integration/#step-1-create-your-implementation-class"
  },"117": {
    "doc": "üîß Platform Integration",
    "title": "Step 2: Platform-Specific Examples",
    "content": "ESP32 (ESP-IDF) . Location: See examples/esp32/main/esp32_pca9685_bus.hpp for a complete ESP32 implementation using ESP-IDF‚Äôs I2C master driver API. For a complete working example, see examples/esp32/main/pca9685_comprehensive_test.cpp. | 1 2 3 4 5 6 7 8 9 10 11 12 13 . | #include \"driver/i2c_master.h\" #include \"pca9685.hpp\" #include \"esp32_pca9685_bus.hpp\" // Use the provided ESP32 bus implementation auto i2c_bus = CreateEsp32Pca9685Bus(); pca9685::PCA9685&lt;Esp32Pca9685Bus&gt; pwm(i2c_bus.get(), 0x40); // Initialize if (!pwm.Reset()) { // Handle error return; } . | . STM32 (HAL) . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 . | #include \"stm32f4xx_hal.h\" #include \"pca9685.hpp\" extern I2C_HandleTypeDef hi2c1; class STM32I2cBus : public pca9685::I2cInterface&lt;STM32I2cBus&gt; { public: bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept { // STM32 HAL uses 8-bit address (7-bit &lt;&lt; 1) return HAL_I2C_Mem_Write(&amp;hi2c1, addr &lt;&lt; 1, reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)data, len, HAL_MAX_DELAY) == HAL_OK; } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept { return HAL_I2C_Mem_Read(&amp;hi2c1, addr &lt;&lt; 1, reg, I2C_MEMADD_SIZE_8BIT, data, len, HAL_MAX_DELAY) == HAL_OK; } bool EnsureInitialized() noexcept { return true; /* HAL_I2C_Init done elsewhere */ } }; . | . Arduino . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 . | #include &lt;Wire.h&gt; #include \"pca9685.hpp\" class ArduinoI2cBus : public pca9685::I2cInterface&lt;ArduinoI2cBus&gt; { public: bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept { Wire.beginTransmission(addr); Wire.write(reg); Wire.write(data, len); return Wire.endTransmission() == 0; } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept { Wire.beginTransmission(addr); Wire.write(reg); if (Wire.endTransmission(false) != 0) return false; Wire.requestFrom(addr, len); for (size_t i = 0; i &lt; len &amp;&amp; Wire.available(); i++) { data[i] = Wire.read(); } return true; } bool EnsureInitialized() noexcept { Wire.begin(); return true; } }; . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#step-2-platform-specific-examples",
    
    "relUrl": "/docs/platform_integration/#step-2-platform-specific-examples"
  },"118": {
    "doc": "üîß Platform Integration",
    "title": "Common Pitfalls",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#common-pitfalls",
    
    "relUrl": "/docs/platform_integration/#common-pitfalls"
  },"119": {
    "doc": "üîß Platform Integration",
    "title": "‚ùå Don‚Äôt Use Virtual Functions",
    "content": "| 1 2 3 4 5 6 7 . | // WRONG - defeats the purpose of CRTP class MyI2c : public pca9685::I2cInterface&lt;MyI2c&gt; { public: virtual bool Write(...) override { // ‚ùå Virtual keyword not needed // ... } }; . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#-dont-use-virtual-functions",
    
    "relUrl": "/docs/platform_integration/#-dont-use-virtual-functions"
  },"120": {
    "doc": "üîß Platform Integration",
    "title": "‚úÖ Correct CRTP Implementation",
    "content": "| 1 2 3 4 5 6 7 . | // CORRECT - no virtual keyword, PascalCase, noexcept class MyI2c : public pca9685::I2cInterface&lt;MyI2c&gt; { public: bool Write(...) noexcept { // ‚úÖ Direct implementation // ... } }; . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#-correct-crtp-implementation",
    
    "relUrl": "/docs/platform_integration/#-correct-crtp-implementation"
  },"121": {
    "doc": "üîß Platform Integration",
    "title": "‚ùå Don‚Äôt Forget the Template Parameter",
    "content": "| 1 2 3 4 . | // WRONG - missing template parameter class MyI2c : public pca9685::I2cInterface { // ‚ùå Compiler error // ... }; . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#-dont-forget-the-template-parameter",
    
    "relUrl": "/docs/platform_integration/#-dont-forget-the-template-parameter"
  },"122": {
    "doc": "üîß Platform Integration",
    "title": "‚úÖ Correct Template Parameter",
    "content": "| 1 2 3 4 . | // CORRECT - pass your class as template parameter class MyI2c : public pca9685::I2cInterface&lt;MyI2c&gt; { // ‚úÖ // ... }; . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#-correct-template-parameter",
    
    "relUrl": "/docs/platform_integration/#-correct-template-parameter"
  },"123": {
    "doc": "üîß Platform Integration",
    "title": "‚ùå Address Format Confusion",
    "content": "The driver uses 7-bit I2C addresses. Some platforms use 8-bit addresses (7-bit ¬´¬†1): . | 1 2 3 4 5 . | // WRONG - if your platform uses 8-bit addresses i2c_write(addr, ...); // ‚ùå Should be addr &lt;&lt; 1 // CORRECT i2c_write(addr &lt;&lt; 1, ...); // ‚úÖ Convert 7-bit to 8-bit . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#-address-format-confusion",
    
    "relUrl": "/docs/platform_integration/#-address-format-confusion"
  },"124": {
    "doc": "üîß Platform Integration",
    "title": "Testing Your Implementation",
    "content": "After implementing the interface, test it: . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . | MyPlatformI2c i2c; pca9685::PCA9685&lt;MyPlatformI2c&gt; pwm(&amp;i2c, 0x40); if (pwm.Reset()) { // Interface works! pwm.SetPwmFreq(50.0f); pwm.SetDuty(0, 0.5f); } else { // Check error flags (uint16_t bitmask) auto flags = pwm.GetErrorFlags(); // Or use convenience accessor: auto error = pwm.GetLastError(); // Debug your I2C implementation pwm.ClearErrorFlags(flags); // Clear after handling } . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#testing-your-implementation",
    
    "relUrl": "/docs/platform_integration/#testing-your-implementation"
  },"125": {
    "doc": "üîß Platform Integration",
    "title": "Next Steps",
    "content": ". | See Configuration for driver configuration options | Check Examples for complete usage examples | Review API Reference for all available methods | . Navigation ‚¨ÖÔ∏è Hardware Setup | Next: Configuration ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#next-steps",
    
    "relUrl": "/docs/platform_integration/#next-steps"
  },"126": {
    "doc": "üîß Platform Integration",
    "title": "üîß Platform Integration",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/",
    
    "relUrl": "/docs/platform_integration/"
  },"127": {
    "doc": "‚ö° Quick Start",
    "title": "Quick Start",
    "content": "This guide will get you up and running with the PCA9685 driver in just a few steps. ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#quick-start",
    
    "relUrl": "/docs/quickstart/#quick-start"
  },"128": {
    "doc": "‚ö° Quick Start",
    "title": "Prerequisites",
    "content": ". | Driver installed | Hardware wired | I2C interface implemented | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#prerequisites",
    
    "relUrl": "/docs/quickstart/#prerequisites"
  },"129": {
    "doc": "‚ö° Quick Start",
    "title": "Minimal Example",
    "content": "Here‚Äôs a complete working example: . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 . | #include \"pca9685.hpp\" // 1. Implement the I2C interface class MyI2c : public pca9685::I2cInterface&lt;MyI2c&gt; { public: bool EnsureInitialized() noexcept { return true; } bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept { // Your I2C write implementation return true; } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept { // Your I2C read implementation return true; } }; // 2. Create instances MyI2c i2c; pca9685::PCA9685&lt;MyI2c&gt; pwm(&amp;i2c, 0x40); // 0x40 is default I2C address // 3. Initialize if (!pwm.Reset()) { // Handle initialization error return; } // 4. Set PWM frequency (required before setting channels) pwm.SetPwmFreq(50.0f); // 50 Hz for servos // 5. Set channel 0 to 50% duty cycle pwm.SetDuty(0, 0.5f); . | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#minimal-example",
    
    "relUrl": "/docs/quickstart/#minimal-example"
  },"130": {
    "doc": "‚ö° Quick Start",
    "title": "Step-by-Step Explanation",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#step-by-step-explanation",
    
    "relUrl": "/docs/quickstart/#step-by-step-explanation"
  },"131": {
    "doc": "‚ö° Quick Start",
    "title": "Step 1: Include the Header",
    "content": "| 1 . | #include \"pca9685.hpp\" . | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#step-1-include-the-header",
    
    "relUrl": "/docs/quickstart/#step-1-include-the-header"
  },"132": {
    "doc": "‚ö° Quick Start",
    "title": "Step 2: Implement the I2C Interface",
    "content": "You need to implement the I2cInterface for your platform. See Platform Integration for detailed examples for ESP32, STM32, and Arduino. The interface requires two methods: . | Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) - Write data to a register | Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) - Read data from a register | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#step-2-implement-the-i2c-interface",
    
    "relUrl": "/docs/quickstart/#step-2-implement-the-i2c-interface"
  },"133": {
    "doc": "‚ö° Quick Start",
    "title": "Step 3: Create Driver Instance",
    "content": "| 1 2 . | MyI2c i2c; pca9685::PCA9685&lt;MyI2c&gt; pwm(&amp;i2c, 0x40); . | . The constructor takes: . | Pointer to your I2C interface implementation | I2C address (0x40 is the default, can be changed via A0-A5 pins) | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#step-3-create-driver-instance",
    
    "relUrl": "/docs/quickstart/#step-3-create-driver-instance"
  },"134": {
    "doc": "‚ö° Quick Start",
    "title": "Step 4: Initialize",
    "content": "| 1 2 3 4 5 . | if (!pwm.Reset()) { // Handle initialization failure uint16_t flags = pwm.GetErrorFlags(); // Bitmask error flags auto error = pwm.GetLastError(); // Convenience accessor } . | . Reset() puts the device in a known state and must be called before other operations. ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#step-4-initialize",
    
    "relUrl": "/docs/quickstart/#step-4-initialize"
  },"135": {
    "doc": "‚ö° Quick Start",
    "title": "Step 5: Set PWM Frequency",
    "content": "| 1 . | pwm.SetPwmFreq(50.0f); // 50 Hz for servos . | . Important: You must set the frequency before setting channel outputs. Valid range is 24-1526 Hz. ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#step-5-set-pwm-frequency",
    
    "relUrl": "/docs/quickstart/#step-5-set-pwm-frequency"
  },"136": {
    "doc": "‚ö° Quick Start",
    "title": "Step 6: Control Channels",
    "content": "| 1 2 3 4 5 . | // Set duty cycle (0.0 = off, 1.0 = fully on) pwm.SetDuty(0, 0.5f); // Channel 0 at 50% // Or set precise timing pwm.SetPwm(1, 0, 2048); // Channel 1: on at 0, off at 2048 (50% duty) . | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#step-6-control-channels",
    
    "relUrl": "/docs/quickstart/#step-6-control-channels"
  },"137": {
    "doc": "‚ö° Quick Start",
    "title": "Expected Output",
    "content": "When running this example with a servo on channel 0: . | The servo should move to its center position (1.5ms pulse at 50 Hz) | No error messages should appear | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#expected-output",
    
    "relUrl": "/docs/quickstart/#expected-output"
  },"138": {
    "doc": "‚ö° Quick Start",
    "title": "Troubleshooting",
    "content": "If you encounter issues: . | Compilation errors: Check that you‚Äôve implemented all required I2C interface methods | Initialization fails: Verify hardware connections and I2C address | No output: Ensure SetPwmFreq() was called before setting channels | See: Troubleshooting for common issues | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#troubleshooting",
    
    "relUrl": "/docs/quickstart/#troubleshooting"
  },"139": {
    "doc": "‚ö° Quick Start",
    "title": "Next Steps",
    "content": ". | Explore Examples for more advanced usage | Review the API Reference for all available methods | Check Configuration for customization options | . Navigation ‚¨ÖÔ∏è Installation | Next: Hardware Setup ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#next-steps",
    
    "relUrl": "/docs/quickstart/#next-steps"
  },"140": {
    "doc": "‚ö° Quick Start",
    "title": "‚ö° Quick Start",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/",
    
    "relUrl": "/docs/quickstart/"
  },"141": {
    "doc": "üêõ Troubleshooting",
    "title": "Troubleshooting",
    "content": "This guide helps you diagnose and resolve common issues when using the PCA9685 driver. ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#troubleshooting",
    
    "relUrl": "/docs/troubleshooting/#troubleshooting"
  },"142": {
    "doc": "üêõ Troubleshooting",
    "title": "Common Error Messages",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#common-error-messages",
    
    "relUrl": "/docs/troubleshooting/#common-error-messages"
  },"143": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Initialization Fails (Reset() returns false)",
    "content": "Symptoms: . | Reset() returns false | GetLastError() returns I2cWrite (or GetErrorFlags() has I2cWrite bit set) | . Causes: . | I2C bus not initialized | Wrong I2C address | Hardware connections incorrect | Pull-up resistors missing | . Solutions: . | Verify I2C bus initialization: | 1 2 3 4 . | // Ensure I2C is initialized before creating driver i2c_config_t conf = { /* your config */ }; i2c_param_config(I2C_NUM_0, &amp;conf); i2c_driver_install(I2C_NUM_0, I2C_MODE_MASTER, 0, 0, 0); . | . | Check I2C address: . | Default is 0x40 (all A0-A5 pins to GND) | Use I2C scanner to verify device address | Update address in constructor if different | . | Verify hardware connections: . | Check SDA/SCL connections | Verify 4.7kŒ© pull-up resistors on SDA and SCL | Ensure power (3.3V or 5V) is connected | . | Test I2C interface: . | Verify your I2C interface implementation works with other devices | Check I2C bus speed (try 100 kHz if 400 kHz fails) | . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#error-initialization-fails-reset-returns-false",
    
    "relUrl": "/docs/troubleshooting/#error-initialization-fails-reset-returns-false"
  },"144": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Frequency Out of Range",
    "content": "Symptoms: . | SetPwmFreq() returns false | GetLastError() returns OutOfRange (or GetErrorFlags() has OutOfRange bit set) | . Causes: . | Frequency value outside valid range (24-1526 Hz) | . Solutions: . | 1 2 3 4 . | // Clamp frequency to valid range float freq = 2000.0f; // Too high freq = std::max(24.0f, std::min(1526.0f, freq)); pwm.SetPwmFreq(freq); . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#error-frequency-out-of-range",
    
    "relUrl": "/docs/troubleshooting/#error-frequency-out-of-range"
  },"145": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Channel Out of Range",
    "content": "Symptoms: . | SetPwm() or SetDuty() returns false | GetLastError() returns OutOfRange (or GetErrorFlags() has OutOfRange bit set) | . Causes: . | Channel number &gt;= 16 | PWM values &gt; 4095 | . Solutions: . | 1 2 3 4 5 6 7 8 9 . | // Validate channel number if (channel &lt; 16) { pwm.SetDuty(channel, 0.5f); } // Validate PWM values if (on_time &lt;= 4095 &amp;&amp; off_time &lt;= 4095) { pwm.SetPwm(channel, on_time, off_time); } . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#error-channel-out-of-range",
    
    "relUrl": "/docs/troubleshooting/#error-channel-out-of-range"
  },"146": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Not Initialized",
    "content": "Symptoms: . | Methods return false | GetLastError() returns NotInitialized (or GetErrorFlags() has NotInitialized bit set) | . Causes: . | Reset() not called before other operations | . Solutions: . | 1 2 3 . | // Always call Reset() first pwm.Reset(); pwm.SetPwmFreq(50.0f); // Now this will work . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#error-not-initialized",
    
    "relUrl": "/docs/troubleshooting/#error-not-initialized"
  },"147": {
    "doc": "üêõ Troubleshooting",
    "title": "Hardware Issues",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#hardware-issues",
    
    "relUrl": "/docs/troubleshooting/#hardware-issues"
  },"148": {
    "doc": "üêõ Troubleshooting",
    "title": "Device Not Detected",
    "content": "Symptoms: . | Initialization fails | No response from device | I2C scanner doesn‚Äôt find device | . Checklist: . | Verify power supply voltage (2.3V-5.5V) | Check all connections are secure | Verify pull-up resistors (4.7kŒ©) on SCL and SDA | Check I2C address configuration (A0-A5 pins) | Use I2C scanner to detect device address | Verify ground connection | Check for short circuits | . Debugging: . | Use oscilloscope/logic analyzer to verify I2C bus activity | Check for proper I2C start/stop conditions | Verify ACK/NACK responses | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#device-not-detected",
    
    "relUrl": "/docs/troubleshooting/#device-not-detected"
  },"149": {
    "doc": "üêõ Troubleshooting",
    "title": "Communication Errors",
    "content": "Symptoms: . | Timeout errors | NACK errors (I2C) | Intermittent failures | . Solutions: . | Check bus speed: | 1 2 3 4 5 6 7 8 . | // Reduce speed if using long wires i2c_config_t conf = { .mode = I2C_MODE_MASTER, .sda_io_num = GPIO_NUM_4, .scl_io_num = GPIO_NUM_5, .master.clk_speed = 100000, // Try 100 kHz instead of 400 kHz // ... }; . | . | Verify signal integrity: . | Check for noise on I2C lines | Ensure proper ground plane | Keep traces short (&lt; 10 cm) | . | Check bus termination: . | Verify pull-up resistors are correct value | Check for multiple pull-ups (should only be one set) | . | Verify power supply: . | Ensure 3.3V/5V is stable | Check for voltage drops under load | Add decoupling capacitor (100 nF) close to VDD pin | . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#communication-errors",
    
    "relUrl": "/docs/troubleshooting/#communication-errors"
  },"150": {
    "doc": "üêõ Troubleshooting",
    "title": "No Output on Channels",
    "content": "Symptoms: . | Driver initializes successfully | No PWM output on channels | Servos/LEDs don‚Äôt respond | . Checklist: . | Did you call SetPwmFreq() before setting channels? | Are channel values within valid range (0-4095)? | Is OE pin pulled LOW (or floating)? (OE HIGH disables outputs) | Are outputs connected correctly? | Check with oscilloscope/multimeter for PWM signal | . Solutions: . | 1 2 3 4 . | // Correct sequence pwm.Reset(); // 1. Initialize pwm.SetPwmFreq(50.0f); // 2. Set frequency (REQUIRED!) pwm.SetDuty(0, 0.5f); // 3. Now set channels . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#no-output-on-channels",
    
    "relUrl": "/docs/troubleshooting/#no-output-on-channels"
  },"151": {
    "doc": "üêõ Troubleshooting",
    "title": "Software Issues",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#software-issues",
    
    "relUrl": "/docs/troubleshooting/#software-issues"
  },"152": {
    "doc": "üêõ Troubleshooting",
    "title": "Compilation Errors",
    "content": "Error: ‚ÄúNo matching function‚Äù . Solution: . | Ensure you‚Äôve implemented all required I2cInterface methods | Check method signatures match exactly: | 1 2 3 . | bool EnsureInitialized() noexcept; bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept; bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept; . | . | . Error: ‚ÄúUndefined reference‚Äù . Solution: . | Verify you‚Äôre including/linking the driver source | For header-only template, ensure pca9685.ipp is accessible | Check include paths are correct | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#compilation-errors",
    
    "relUrl": "/docs/troubleshooting/#compilation-errors"
  },"153": {
    "doc": "üêõ Troubleshooting",
    "title": "Runtime Errors",
    "content": "Initialization Fails . Checklist: . | I2C bus is properly initialized | Hardware connections are correct | I2C address matches hardware configuration | Pull-up resistors are present | . Unexpected Behavior . Checklist: . | Frequency is set before setting channels | Channel numbers are 0-15 | Duty cycle values are 0.0-1.0 | PWM values are 0-4095 | Error handling code checks return values | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#runtime-errors",
    
    "relUrl": "/docs/troubleshooting/#runtime-errors"
  },"154": {
    "doc": "üêõ Troubleshooting",
    "title": "Debugging Tips",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#debugging-tips",
    
    "relUrl": "/docs/troubleshooting/#debugging-tips"
  },"155": {
    "doc": "üêõ Troubleshooting",
    "title": "Enable Debug Output",
    "content": "Add debug prints to your I2C interface: . | 1 2 3 4 5 6 7 . | bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept { printf(\"I2C Write: addr=0x%02X, reg=0x%02X, len=%zu\\n\", addr, reg, len); // ... your implementation bool result = /* ... */; printf(\"I2C Write result: %s\\n\", result ? \"OK\" : \"FAIL\"); return result; } . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#enable-debug-output",
    
    "relUrl": "/docs/troubleshooting/#enable-debug-output"
  },"156": {
    "doc": "üêõ Troubleshooting",
    "title": "Use I2C Scanner",
    "content": "Scan the I2C bus to verify device detection: . | 1 2 3 4 5 6 7 8 . | void i2c_scanner() { for (uint8_t addr = 0x08; addr &lt; 0x78; addr++) { // Try to write to address if (/* device responds */) { printf(\"Device found at 0x%02X\\n\", addr); } } } . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#use-i2c-scanner",
    
    "relUrl": "/docs/troubleshooting/#use-i2c-scanner"
  },"157": {
    "doc": "üêõ Troubleshooting",
    "title": "Check Error Flags",
    "content": "Always check and log error flags. Errors are now uint16_t bitmask flags: . | 1 2 3 4 5 6 7 8 9 10 . | if (!pwm.SetPwmFreq(50.0f)) { // Preferred: use bitmask error flags uint16_t flags = pwm.GetErrorFlags(); printf(\"Error flags: 0x%04X\\n\", flags); pwm.ClearErrorFlags(flags); // Clear after handling // Or use convenience accessor auto error = pwm.GetLastError(); printf(\"Error: %d\\n\", static_cast&lt;int&gt;(error)); } . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#check-error-flags",
    
    "relUrl": "/docs/troubleshooting/#check-error-flags"
  },"158": {
    "doc": "üêõ Troubleshooting",
    "title": "Use Logic Analyzer",
    "content": "For I2C communication issues, a logic analyzer can help: . | Verify correct I2C protocol | Check for ACK/NACK responses | Identify timing issues | Debug address conflicts | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#use-logic-analyzer",
    
    "relUrl": "/docs/troubleshooting/#use-logic-analyzer"
  },"159": {
    "doc": "üêõ Troubleshooting",
    "title": "FAQ",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#faq",
    
    "relUrl": "/docs/troubleshooting/#faq"
  },"160": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: Why do I need to call SetPwmFreq() before setting channels?",
    "content": "A: The PCA9685 requires the prescale register to be set before PWM outputs work correctly. The driver enforces this by checking initialization state. Always call Reset() then SetPwmFreq() before setting channels. ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#q-why-do-i-need-to-call-setpwmfreq-before-setting-channels",
    
    "relUrl": "/docs/troubleshooting/#q-why-do-i-need-to-call-setpwmfreq-before-setting-channels"
  },"161": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: Can I change frequency after setting channels?",
    "content": "A: Yes, but it will affect all channels. Changing frequency updates the prescale register, which changes the PWM period for all 16 channels simultaneously. ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#q-can-i-change-frequency-after-setting-channels",
    
    "relUrl": "/docs/troubleshooting/#q-can-i-change-frequency-after-setting-channels"
  },"162": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: What‚Äôs the difference between SetPwm() and SetDuty()?",
    "content": "A: . | SetPwm() gives you precise control over on/off timing (0-4095 ticks each) | SetDuty() is a convenience method that sets duty cycle as a float (0.0-1.0), automatically calculating the off_time | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#q-whats-the-difference-between-setpwm-and-setduty",
    
    "relUrl": "/docs/troubleshooting/#q-whats-the-difference-between-setpwm-and-setduty"
  },"163": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: Can I use multiple PCA9685 devices?",
    "content": "A: Yes! Configure different I2C addresses via A0-A5 pins, then create separate driver instances: . | 1 2 . | pca9685::PCA9685&lt;MyI2c&gt; pwm1(&amp;i2c, 0x40); // First device pca9685::PCA9685&lt;MyI2c&gt; pwm2(&amp;i2c, 0x41); // Second device . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#q-can-i-use-multiple-pca9685-devices",
    
    "relUrl": "/docs/troubleshooting/#q-can-i-use-multiple-pca9685-devices"
  },"164": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: Why are my servos not moving?",
    "content": "A: Common causes: . | Frequency not set (must call SetPwmFreq(50.0f) first) | Duty cycle out of servo range (try 0.05-0.10) | Servo power supply insufficient | OE pin pulled HIGH (disables outputs) | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#q-why-are-my-servos-not-moving",
    
    "relUrl": "/docs/troubleshooting/#q-why-are-my-servos-not-moving"
  },"165": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: How do I control the OE (Output Enable) pin?",
    "content": "A: The driver doesn‚Äôt control OE. You must control it via your platform‚Äôs GPIO: . | 1 2 3 . | // Example: ESP32 gpio_set_direction(OE_PIN, GPIO_MODE_OUTPUT); gpio_set_level(OE_PIN, 0); // Enable outputs . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#q-how-do-i-control-the-oe-output-enable-pin",
    
    "relUrl": "/docs/troubleshooting/#q-how-do-i-control-the-oe-output-enable-pin"
  },"166": {
    "doc": "üêõ Troubleshooting",
    "title": "Getting More Help",
    "content": "If you‚Äôre still experiencing issues: . | Check the API Reference for method details | Review Examples for working code | Search existing issues on GitHub | Open a new issue with: . | Description of the problem | Steps to reproduce | Hardware setup details | Error messages/logs | I2C bus analyzer output (if available) | . | . Navigation ‚¨ÖÔ∏è Examples | Back to Index . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#getting-more-help",
    
    "relUrl": "/docs/troubleshooting/#getting-more-help"
  },"167": {
    "doc": "üêõ Troubleshooting",
    "title": "üêõ Troubleshooting",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/",
    
    "relUrl": "/docs/troubleshooting/"
  },"168": {
    "doc": "PCAL9555 ESP32-C6 Comprehensive Test Suite",
    "title": "PCAL9555 ESP32-C6 Comprehensive Test Suite",
    "content": "# PCAL9555 ESP32-C6 Comprehensive Test Suite This directory contains comprehensive test suites for the PCAL9555 16-bit I/O expander driver using the ESP32-C6 DevKit-M-1. ## üìã Table of Contents - [Hardware Overview](#-hardware-overview) - [Pin Connections](#-pin-connections) - [Hardware Setup](#-hardware-setup) - [Building the Tests](#-building-the-tests) - [Running the Tests](#-running-the-tests) - [Test Suites](#-test-suites) - [Troubleshooting](#-troubleshooting) --- ## üîå Hardware Overview ### ESP32-C6 DevKit-M-1 The ESP32-C6 DevKit-M-1 serves as the host controller for communicating with the PCAL9555 GPIO expander via I2C. ``` ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ESP32-C6 DevKit-M-1 ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ ESP32-C6 Microcontroller ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ GPIO Pins: ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ I2C: SDA (GPIO4), SCL (GPIO5) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Test Indicator: GPIO14 ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ USB-C Connector ‚îÇ ‚îÇ (Power + Serial Communication) ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ``` ### PCAL9555 GPIO Expander The PCAL9555 is a 16-bit I/O expander with I¬≤C interface, providing 16 GPIO pins organized into two 8-bit ports. ``` ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ PCAL9555 GPIO Expander ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ PCAL9555 IC ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ Features: ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ 16 GPIO pins (PORT_0: P0.0-P0.7) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ 16 GPIO pins (PORT_1: P1.0-P1.7) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ I2C interface (7-bit address) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Configurable pull-up/pull-down ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Programmable drive strength ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Interrupt support ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Input latch capability ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Polarity inversion ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Open-drain output mode ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ I2C Connections: ‚îÇ ‚îÇ ‚Ä¢ SDA (I2C Data) ‚îÇ ‚îÇ ‚Ä¢ SCL (I2C Clock) ‚îÇ ‚îÇ ‚Ä¢ VDD (3.3V Power) ‚îÇ ‚îÇ ‚Ä¢ GND (Ground) ‚îÇ ‚îÇ ‚Ä¢ INT (Interrupt Output, optional) ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ``` --- ## üìå Pin Connections ### I2C Bus Connections | PCAL9555 Pin | ESP32-C6 GPIO | Function | Notes |--------------|---------------|----------|-------| SDA | GPIO4 | I2C Data | With 4.7kŒ© pull-up to 3.3V | SCL | GPIO5 | I2C Clock | With 4.7kŒ© pull-up to 3.3V | VDD | 3.3V | Power Supply | | GND | GND | Ground | | INT | GPIO15 (optional) | Interrupt Output | Open-drain, requires pull-up | ### Test Indicator | Signal | ESP32-C6 GPIO | Function |--------|---------------|----------| Test Progress | GPIO14 | Visual test progression indicator | ### I2C Address Configuration The PCAL9555 I2C address is determined by the A0, A1, and A2 address pins: | A2 | A1 | A0 | I2C Address (7-bit) | I2C Address (8-bit) |----|----|----|---------------------|---------------------| GND | GND | GND | 0x20 | 0x40 | GND | GND | VDD | 0x21 | 0x42 | GND | VDD | GND | 0x22 | 0x44 | GND | VDD | VDD | 0x23 | 0x46 | VDD | GND | GND | 0x24 | 0x48 | VDD | GND | VDD | 0x25 | 0x4A | VDD | VDD | GND | 0x26 | 0x4C | VDD | VDD | VDD | 0x27 | 0x4E | **Default**: All address pins to GND = **0x20** (used in examples) --- ## üõ†Ô∏è Hardware Setup ### Basic Setup 1. **Connect I2C Bus**: - Connect PCAL9555 SDA to ESP32-C6 GPIO4 - Connect PCAL9555 SCL to ESP32-C6 GPIO5 - Add 4.7kŒ© pull-up resistors on both SDA and SCL to 3.3V 2. **Power Connections**: - Connect PCAL9555 VDD to ESP32-C6 3.3V - Connect PCAL9555 GND to ESP32-C6 GND 3. **Optional Interrupt**: - Connect PCAL9555 INT to ESP32-C6 GPIO15 (with pull-up resistor) 4. **Address Configuration**: - Connect A0, A1, A2 to GND for default address 0x20 - Or configure for different address if needed ### Test Setup For comprehensive testing, you can connect: - LEDs to output pins (with current-limiting resistors) - Switches/buttons to input pins - External pull-up/pull-down resistors for testing - Logic analyzer on I2C bus for protocol verification --- ## üöÄ Building the Tests ### Prerequisites 1. **Install ESP-IDF** (if not already installed): ```bash # Clone ESP-IDF git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf # Checkout release version 5.5 git checkout release/v5.5 git submodule update --init --recursive # Install ESP-IDF (Linux/macOS) ./install.sh esp32c6 # Set up environment (add to ~/.bashrc or ~/.zshrc for persistence) ./export.sh ``` 2. **Navigate to ESP32 Examples**: ```bash cd examples/esp32 ``` 3. **Setup Repository** (First time only): ```bash # Make scripts executable and setup the build environment chmod +x scripts/*.sh ./scripts/setup_repo.sh ``` ### Available Test Applications The test suites use a centralized build system with scripts. Available applications: | **Application Name** | **Description** | **Hardware Required** |----------------------|----------------|----------------------| `pcal9555_comprehensive_test` | Comprehensive PCAL9555 GPIO expander testing with all features | PCAL9555 board | ### List Available Applications ```bash # List all available applications ./scripts/build_app.sh list ``` ### Build an Application ```bash # Build comprehensive test (Debug build) ./scripts/build_app.sh pcal9555_comprehensive_test Debug # Build comprehensive test (Release build) ./scripts/build_app.sh pcal9555_comprehensive_test Release ``` --- ## üì§ Running the Tests ### Flash Application ```bash # Flash the application to ESP32-C6 ./scripts/flash_app.sh pcal9555_comprehensive_test Debug # Or manually: idf.py -p /dev/ttyUSB0 flash ``` ### Monitor Output ```bash # Monitor serial output idf.py -p /dev/ttyUSB0 monitor # Or use the flash script which includes monitoring ./scripts/flash_app.sh pcal9555_comprehensive_test Debug ``` ### Auto-detect Port ```bash # The scripts can auto-detect the port ./scripts/detect_ports.sh ``` --- ## üß™ Test Suites ### Comprehensive Test Suite **Application**: `pcal9555_comprehensive_test` This comprehensive test suite validates all PCAL9555 functionality: #### Test Sections 1. **Initialization Tests** - I2C bus initialization - Driver initialization - Reset to default state 2. **GPIO Direction Tests** - Single pin direction configuration (input/output) - Multiple pin direction configuration - Port-level direction control 3. **GPIO Read/Write Tests** - Pin write operations (HIGH/LOW) - Pin read operations - Pin toggle operations - Port-level read/write 4. **Pull Resistor Tests** - Pull-up resistor configuration - Pull-down resistor configuration - Pull enable/disable - Per-pin pull configuration 5. **Drive Strength Tests** - All drive strength levels (Level0-Level3) - Per-pin drive strength configuration 6. **Output Mode Tests** - Push-pull mode configuration - Open-drain mode configuration - Port-level output mode control 7. **Polarity Tests** - Input polarity inversion (normal/inverted) - Single pin polarity configuration - Multiple pin polarity configuration 8. **Input Latch Tests** - Input latch enable/disable - Single pin latch configuration - Multiple pin latch configuration 9. **Interrupt Tests** - Interrupt mask configuration - Interrupt status reading - Interrupt callback registration 10. **Port Operation Tests** - Port 0 operations (pins 0-7) - Port 1 operations (pins 8-15) - Mixed port operations 11. **Error Handling Tests** - Invalid pin handling - Error flag management - Error recovery 12. **Stress Tests** - Rapid pin operations - Continuous read/write cycles - Multi-pin simultaneous operations #### Test Configuration You can enable/disable specific test sections by editing the test file: ```cpp // In PCAL9555ComprehensiveTest.cpp static constexpr bool ENABLE_INITIALIZATION_TESTS = true; static constexpr bool ENABLE_GPIO_DIRECTION_TESTS = true; // ... etc ``` #### Test Results The test framework provides: - Automatic pass/fail tracking - Execution time measurement - GPIO14 progress indicator (toggles on each test) - Comprehensive test summary - Success percentage calculation --- ## üîß Configuration ### I2C Bus Configuration Default I2C configuration (can be modified in test file): ```cpp Esp32Pcal9555Bus::I2CConfig config; config.port = I2C_NUM_0; config.sda_pin = GPIO_NUM_4; // SDA pin config.scl_pin = GPIO_NUM_5; // SCL pin config.frequency = 400000; // 400 kHz config.pullup_enable = true; // Enable internal pullups ``` ### PCAL9555 Address Default I2C address (can be modified in test file): ```cpp static constexpr uint8_t PCAL9555_I2C_ADDRESS = 0x20; // Default address ``` --- ## üêõ Troubleshooting ### I2C Communication Failures **Symptoms**: Tests fail with I2C errors **Solutions**: 1. **Check I2C connections**: - Verify SDA/SCL connections - Check pull-up resistors (4.7kŒ© recommended) - Ensure proper power connections 2. **Verify I2C address**: - Check A0, A1, A2 pin configuration - Use I2C scanner to detect device address - Update `PCAL9555_I2C_ADDRESS` if different 3. **Check I2C bus speed**: - Reduce frequency if using long wires - Try 100 kHz instead of 400 kHz 4. **Verify power supply**: - Ensure 3.3V is stable - Check for voltage drops ### Build Errors **Symptoms**: CMake or compilation errors **Solutions**: 1. **Verify ESP-IDF version**: ```bash idf.py --version # Should show ESP-IDF v5.5 or compatible ``` 2. **Clean and rebuild**: ```bash idf.py fullclean ./scripts/build_app.sh pcal9555_comprehensive_test Debug ``` 3. **Check component paths**: - Verify component CMakeLists.txt paths - Ensure source files are accessible ### Test Failures **Symptoms**: Specific tests fail **Solutions**: 1. **Check hardware connections**: - Verify all pins are properly connected - Check for loose connections 2. **Review test logs**: - Check which specific test failed - Review error messages in serial output 3. **Verify device state**: - Reset PCAL9555 (power cycle) - Run reset test first --- ## üìö Additional Resources - [PCAL9555 Datasheet](../../datasheet/PCAL9555A.pdf) - [Driver API Documentation](/hf-pca9685-driver/development/docs/api_reference/) - [Platform Integration Guide](/hf-pca9685-driver/development/docs/platform_integration/) - [Hardware Overview](../../docs/hardware_overview.md) --- ## üéØ Quick Reference ### Build Commands ```bash # List available apps ./scripts/build_app.sh list # Build comprehensive test ./scripts/build_app.sh pcal9555_comprehensive_test Debug # Flash and monitor ./scripts/flash_app.sh pcal9555_comprehensive_test Debug ``` ### Test Execution The comprehensive test suite runs automatically on boot and provides: - Real-time test progress via GPIO14 indicator - Serial output with detailed test results - Automatic test summary at completion ### GPIO14 Test Indicator GPIO14 toggles between HIGH/LOW for each completed test, providing visual feedback: - Use oscilloscope or logic analyzer to monitor - Useful for automated test verification - Blinks 5 times at section start/end --- ## üìù Notes - **I2C Pull-ups**: External pull-up resistors (4.7kŒ©) are recommended even if internal pullups are enabled - **Address Configuration**: Default address is 0x20. Modify if using different A0/A1/A2 configuration - **Test Duration**: Comprehensive test suite takes approximately 2-5 minutes to complete - **Hardware Requirements**: Basic tests work without external hardware; some tests benefit from LEDs/switches --- üéØ Ready to test the PCAL9555? Start with: ./scripts/build_app.sh pcal9555_comprehensive_test Debug ",
    "url": "/hf-pca9685-driver/development/examples/esp32/",
    
    "relUrl": "/examples/esp32/"
  }
}

{"0": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "HF-PCA9685 Driver",
    "content": "Hardware-agnostic C++ driver for the NXP PCA9685 16-channel 12-bit PWM controller . ",
    "url": "/hf-pca9685-driver/development/#hf-pca9685-driver",
    
    "relUrl": "/#hf-pca9685-driver"
  },"1": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üìö Table of Contents",
    "content": ". | Overview | Features | Quick Start | Installation | API Reference | Examples | Documentation | Contributing | License | . ",
    "url": "/hf-pca9685-driver/development/#-table-of-contents",
    
    "relUrl": "/#-table-of-contents"
  },"2": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üì¶ Overview",
    "content": "üìñ üìöüåê Live Complete Documentation - Interactive guides, examples, and step-by-step tutorials . The PCA9685 is a 16-channel, 12-bit PWM controller from NXP Semiconductors that communicates via I¬≤C. It provides independent PWM control for up to 16 outputs with 12-bit resolution (4096 steps), making it ideal for driving LEDs, servos, and other PWM-controlled devices. The chip features an internal 25 MHz oscillator, configurable PWM frequency from 24 Hz to 1526 Hz, and supports daisy-chaining multiple devices for up to 992 PWM outputs. This driver provides a hardware-agnostic C++ interface that abstracts all register-level operations, requiring only an implementation of the I2cInterface for your platform. The driver uses the CRTP (Curiously Recurring Template Pattern) for zero-overhead hardware abstraction, making it suitable for resource-constrained embedded systems. ",
    "url": "/hf-pca9685-driver/development/#-overview",
    
    "relUrl": "/#-overview"
  },"3": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "‚ú® Features",
    "content": ". | ‚úÖ 16 Independent PWM Channels: Each with 12-bit resolution (0-4095) | ‚úÖ Configurable Frequency: 24 Hz to 1526 Hz (typical range) | ‚úÖ Hardware Agnostic: CRTP-based I2C interface for platform independence | ‚úÖ Modern C++: C++11 compatible with template-based design | ‚úÖ Zero Overhead: CRTP design for compile-time polymorphism | ‚úÖ Error Reporting: Bitmask error flags (uint16_t) via GetErrorFlags() / ClearErrorFlags() | ‚úÖ Duty Cycle Control: High-level SetDuty() method for easy 0.0-1.0 control | ‚úÖ Bulk Operations: SetAllPwm() for simultaneous channel updates | ‚úÖ Power Management: Sleep() / Wake() via MODE1 SLEEP bit | ‚úÖ Output Modes: SetOutputInvert(), SetOutputDriverMode() (totem-pole/open-drain) | ‚úÖ Full ON/OFF: SetChannelFullOn() / SetChannelFullOff() without PWM | ‚úÖ Retry Logic: Configurable I2C retry count via SetRetries() | . ",
    "url": "/hf-pca9685-driver/development/#-features",
    
    "relUrl": "/#-features"
  },"4": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üöÄ Quick Start",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 . | #include \"pca9685.hpp\" // 1. Implement the I2C interface (see platform_integration.md) class MyI2c : public pca9685::I2cInterface&lt;MyI2c&gt; { public: bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept; bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept; bool EnsureInitialized() noexcept; }; // 2. Create driver instance MyI2c i2c; pca9685::PCA9685&lt;MyI2c&gt; pwm(&amp;i2c, 0x40); // 0x40 is default I2C address // 3. Initialize and use pwm.Reset(); pwm.SetPwmFreq(50.0f); // 50 Hz for servos pwm.SetDuty(0, 0.075f); // Channel 0, 7.5% duty (1.5ms pulse for servo) . | . For detailed setup, see Installation and Quick Start Guide. ",
    "url": "/hf-pca9685-driver/development/#-quick-start",
    
    "relUrl": "/#-quick-start"
  },"5": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üîß Installation",
    "content": ". | Clone or copy the driver files into your project | Implement the I2C interface for your platform (see Platform Integration) | Include the header in your code: | 1 . | #include \"pca9685.hpp\" . | . | Compile with a C++11 or newer compiler | . For detailed installation instructions, see docs/installation.md. ",
    "url": "/hf-pca9685-driver/development/#-installation",
    
    "relUrl": "/#-installation"
  },"6": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üìñ API Reference",
    "content": "| Method | Description | . | Reset() | Reset device to power-on default state | . | SetPwmFreq(float freq_hz) | Set PWM frequency (24-1526 Hz) | . | SetPwm(uint8_t channel, uint16_t on, uint16_t off) | Set PWM timing for a channel | . | SetDuty(uint8_t channel, float duty) | Set duty cycle (0.0-1.0) for a channel | . | SetAllPwm(uint16_t on, uint16_t off) | Set all channels simultaneously | . | SetChannelFullOn(uint8_t channel) | Set channel fully on (no PWM) | . | SetChannelFullOff(uint8_t channel) | Set channel fully off (no PWM) | . | Sleep() / Wake() | Power management via MODE1 SLEEP bit | . | SetOutputInvert(bool invert) | Set MODE2 INVRT bit | . | SetOutputDriverMode(bool totem_pole) | Set MODE2 OUTDRV bit (true=totem-pole, false=open-drain) | . | SetRetries(int retries) | Configure I2C retry count | . | GetLastError() | Get the last error code (convenience accessor) | . | GetErrorFlags() | Get all error flags as uint16_t bitmask | . | ClearErrorFlags(uint16_t mask) | Clear specific error flags | . | GetPrescale(uint8_t &amp;prescale) | Get current prescale value | . For complete API documentation with source code links, see docs/api_reference.md. ",
    "url": "/hf-pca9685-driver/development/#-api-reference",
    
    "relUrl": "/#-api-reference"
  },"7": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üìä Examples",
    "content": ". | ESP32: examples/esp32 ‚Äî two apps: pca9685_comprehensive_test (full driver test suite) and pca9685_servo_demo (16-channel hobby servo animations). See examples/esp32/README.md for build/flash and examples/esp32/docs/ for per-app documentation. | Driver examples (code snippets, any platform): docs/examples.md. | . ",
    "url": "/hf-pca9685-driver/development/#-examples",
    
    "relUrl": "/#-examples"
  },"8": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üìö Documentation",
    "content": "For complete documentation, see the docs directory. ",
    "url": "/hf-pca9685-driver/development/#-documentation",
    
    "relUrl": "/#-documentation"
  },"9": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "ü§ù Contributing",
    "content": "Pull requests and suggestions are welcome! Please follow the existing code style and include tests for new features. ",
    "url": "/hf-pca9685-driver/development/#-contributing",
    
    "relUrl": "/#-contributing"
  },"10": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "üìÑ License",
    "content": "This project is licensed under the GNU General Public License v3.0. See the LICENSE file for details. ",
    "url": "/hf-pca9685-driver/development/#-license",
    
    "relUrl": "/#-license"
  },"11": {
    "doc": "HardFOC PCA9685 Driver",
    "title": "HardFOC PCA9685 Driver",
    "content": " ",
    "url": "/hf-pca9685-driver/development/",
    
    "relUrl": "/"
  },"12": {
    "doc": "üìñ API Reference",
    "title": "API Reference",
    "content": "Complete reference documentation for all public methods and types in the PCA9685 driver. ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#api-reference",
    
    "relUrl": "/docs/api_reference/#api-reference"
  },"13": {
    "doc": "üìñ API Reference",
    "title": "Source Code",
    "content": ". | Main Header: inc/pca9685.hpp | I2C Interface: inc/pca9685_i2c_interface.hpp | Implementation: src/pca9685.ipp (template implementation, included by header) | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#source-code",
    
    "relUrl": "/docs/api_reference/#source-code"
  },"14": {
    "doc": "üìñ API Reference",
    "title": "Core Class",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#core-class",
    
    "relUrl": "/docs/api_reference/#core-class"
  },"15": {
    "doc": "üìñ API Reference",
    "title": "PCA9685&lt;I2cType&gt;",
    "content": "Main driver class for interfacing with the PCA9685 PWM controller. Template Parameter: I2cType - Your I2C interface implementation (must inherit from pca9685::I2cInterface&lt;I2cType&gt;) . Location: inc/pca9685.hpp . Constructor: . | 1 . | PCA9685(I2cType* bus, uint8_t address); . | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#pca9685i2ctype",
    
    "relUrl": "/docs/api_reference/#pca9685i2ctype"
  },"16": {
    "doc": "üìñ API Reference",
    "title": "Methods",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#methods",
    
    "relUrl": "/docs/api_reference/#methods"
  },"17": {
    "doc": "üìñ API Reference",
    "title": "Initialization",
    "content": "| Method | Signature | Description | . | EnsureInitialized() | bool EnsureInitialized() noexcept | Lazy initialization - ensures bus and device are ready | . | IsInitialized() | bool IsInitialized() const noexcept | Check if driver has been initialized | . | Reset() | bool Reset() noexcept | Reset device to power-on default state | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#initialization",
    
    "relUrl": "/docs/api_reference/#initialization"
  },"18": {
    "doc": "üìñ API Reference",
    "title": "Frequency Control",
    "content": "| Method | Signature | Description | . | SetPwmFreq() | bool SetPwmFreq(float freq_hz) noexcept | Set PWM frequency for all channels (24-1526 Hz) | . | GetPrescale() | bool GetPrescale(uint8_t&amp; prescale) noexcept | Get current prescale register value | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#frequency-control",
    
    "relUrl": "/docs/api_reference/#frequency-control"
  },"19": {
    "doc": "üìñ API Reference",
    "title": "PWM Control",
    "content": "| Method | Signature | Description | . | SetPwm() | bool SetPwm(uint8_t channel, uint16_t on_time, uint16_t off_time) noexcept | Set PWM on/off time for a channel | . | SetDuty() | bool SetDuty(uint8_t channel, float duty) noexcept | Set duty cycle (0.0-1.0) for a channel | . | SetAllPwm() | bool SetAllPwm(uint16_t on_time, uint16_t off_time) noexcept | Set all channels to the same PWM value | . | SetChannelFullOn() | bool SetChannelFullOn(uint8_t channel) noexcept | Set channel to fully ON (100% duty) | . | SetChannelFullOff() | bool SetChannelFullOff(uint8_t channel) noexcept | Set channel to fully OFF (0% duty) | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#pwm-control",
    
    "relUrl": "/docs/api_reference/#pwm-control"
  },"20": {
    "doc": "üìñ API Reference",
    "title": "Power Management",
    "content": "| Method | Signature | Description | . | Sleep() | bool Sleep() noexcept | Put PCA9685 into low-power sleep mode | . | Wake() | bool Wake() noexcept | Wake PCA9685 from sleep mode | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#power-management",
    
    "relUrl": "/docs/api_reference/#power-management"
  },"21": {
    "doc": "üìñ API Reference",
    "title": "Output Configuration",
    "content": "| Method | Signature | Description | . | SetOutputInvert() | bool SetOutputInvert(bool invert) noexcept | Set output polarity inversion | . | SetOutputDriverMode() | bool SetOutputDriverMode(bool totem_pole) noexcept | Set totem-pole or open-drain mode | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#output-configuration",
    
    "relUrl": "/docs/api_reference/#output-configuration"
  },"22": {
    "doc": "üìñ API Reference",
    "title": "Error Handling",
    "content": "| Method | Signature | Description | . | GetLastError() | Error GetLastError() const noexcept | Get last error code (single-error convenience) | . | GetErrorFlags() | uint16_t GetErrorFlags() const noexcept | Get accumulated error flags (bitmask) | . | HasError() | bool HasError(Error e) const noexcept | Check if a specific error flag is set | . | HasAnyError() | bool HasAnyError() const noexcept | Check if any error flag is set | . | ClearError() | void ClearError(Error e) noexcept | Clear a single error flag | . | ClearErrorFlags() | void ClearErrorFlags(uint16_t mask = 0xFFFF) noexcept | Clear error flags by bitmask | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#error-handling",
    
    "relUrl": "/docs/api_reference/#error-handling"
  },"23": {
    "doc": "üìñ API Reference",
    "title": "Configuration",
    "content": "| Method | Signature | Description | . | SetRetries() | void SetRetries(int retries) noexcept | Set I2C retry count for register operations | . | SetRetryDelay() | void SetRetryDelay(RetryDelayFn fn) noexcept | Set optional callback invoked between retries (e.g. 1 ms delay for bus recovery); default nullptr | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#configuration",
    
    "relUrl": "/docs/api_reference/#configuration"
  },"24": {
    "doc": "üìñ API Reference",
    "title": "Types",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#types",
    
    "relUrl": "/docs/api_reference/#types"
  },"25": {
    "doc": "üìñ API Reference",
    "title": "Type Aliases",
    "content": "| Type | Definition | Description | . | RetryDelayFn | void (*)() | Optional callback for delay between I2C retries; used with SetRetryDelay(). | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#type-aliases",
    
    "relUrl": "/docs/api_reference/#type-aliases"
  },"26": {
    "doc": "üìñ API Reference",
    "title": "Enumerations",
    "content": "| Type | Values | Location | . | Error | None, I2cWrite, I2cRead, InvalidParam, DeviceNotFound, NotInitialized, OutOfRange | inc/pca9685.hpp | . | Register | MODE1, MODE2, LED0_ON_L, LED0_OFF_L, PRE_SCALE, etc. | inc/pca9685.hpp | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#enumerations",
    
    "relUrl": "/docs/api_reference/#enumerations"
  },"27": {
    "doc": "üìñ API Reference",
    "title": "Constants",
    "content": "| Constant | Value | Description | . | MAX_CHANNELS_ | 16 | Maximum number of PWM channels | . | MAX_PWM_ | 4095 | Maximum PWM value (12-bit) | . | OSC_FREQ_ | 25000000 | Internal oscillator frequency (25 MHz) | . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#constants",
    
    "relUrl": "/docs/api_reference/#constants"
  },"28": {
    "doc": "üìñ API Reference",
    "title": "I2C Interface",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#i2c-interface",
    
    "relUrl": "/docs/api_reference/#i2c-interface"
  },"29": {
    "doc": "üìñ API Reference",
    "title": "I2cInterface&lt;Derived&gt; (CRTP)",
    "content": "Hardware-agnostic I2C interface using the Curiously Recurring Template Pattern. Location: inc/pca9685_i2c_interface.hpp . The interface is non-copyable and non-movable; use references or pointers to the concrete bus type. | Method | Signature | Description | . | Write() | bool Write(uint8_t addr, uint8_t reg, const uint8_t* data, size_t len) noexcept | Write bytes to a device register | . | Read() | bool Read(uint8_t addr, uint8_t reg, uint8_t* data, size_t len) noexcept | Read bytes from a device register | . | EnsureInitialized() | bool EnsureInitialized() noexcept | Ensure I2C bus is initialized and ready | . The driver supports an optional retry delay via SetRetryDelay() (a function pointer). The I2C implementation can expose a static delay (e.g. Esp32Pca9685Bus::RetryDelay) and the app passes it to the driver after construction. Navigation ‚¨ÖÔ∏è Configuration | Next: Examples ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/#i2cinterfacederived-crtp",
    
    "relUrl": "/docs/api_reference/#i2cinterfacederived-crtp"
  },"30": {
    "doc": "üìñ API Reference",
    "title": "üìñ API Reference",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/api_reference/",
    
    "relUrl": "/docs/api_reference/"
  },"31": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Configuration",
    "content": "This guide covers all configuration options available for the PCA9685 driver. ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#configuration",
    
    "relUrl": "/docs/configuration/#configuration"
  },"32": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "I2C Address Configuration",
    "content": "The PCA9685 I2C address is configured via hardware pins A0-A5. Each pin represents one bit of the 6-bit address field. | Pin | Address Bit | Description | . | A0 | Bit 0 | Least significant address bit | . | A1 | Bit 1 | ¬† | . | A2 | Bit 2 | ¬† | . | A3 | Bit 3 | ¬† | . | A4 | Bit 4 | ¬† | . | A5 | Bit 5 | Most significant address bit | . Default I2C address: 0x40 (all address pins to GND) . Address Range: 0x40 to 0x7F (7-bit I2C addresses) . Example: To set address 0x41, connect A0 to VDD and A1-A5 to GND. ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#i2c-address-configuration",
    
    "relUrl": "/docs/configuration/#i2c-address-configuration"
  },"33": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "PWM Frequency Configuration",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#pwm-frequency-configuration",
    
    "relUrl": "/docs/configuration/#pwm-frequency-configuration"
  },"34": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Setting Frequency",
    "content": "Use the SetPwmFreq() method to configure the PWM frequency: . | 1 2 . | pwm.SetPwmFreq(50.0f); // 50 Hz for servos pwm.SetPwmFreq(1000.0f); // 1 kHz for LEDs . | . Valid Range: 24 Hz to 1526 Hz (typical) . Location: src/pca9685.ipp (template implementation) . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#setting-frequency",
    
    "relUrl": "/docs/configuration/#setting-frequency"
  },"35": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Frequency Calculation",
    "content": "The driver automatically calculates the prescale value using the formula: . | 1 . | prescale = round(25,000,000 / (4096 * freq_hz)) - 1 . | . Where: . | 25,000,000 is the internal oscillator frequency (25 MHz) | 4096 is the PWM resolution (12 bits) | freq_hz is the desired frequency | . Implementation: src/pca9685.ipp (calcPrescale) . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#frequency-calculation",
    
    "relUrl": "/docs/configuration/#frequency-calculation"
  },"36": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Common Frequencies",
    "content": "| Application | Frequency | Prescale (approx) | . | Servos | 50 Hz | 121 | . | LEDs (smooth dimming) | 1000 Hz | 5 | . | Motors | 100-500 Hz | 11-61 | . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#common-frequencies",
    
    "relUrl": "/docs/configuration/#common-frequencies"
  },"37": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Channel Configuration",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#channel-configuration",
    
    "relUrl": "/docs/configuration/#channel-configuration"
  },"38": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Individual Channel Control",
    "content": "Set PWM for a single channel: . | 1 2 3 4 5 . | // Set channel 0: on at tick 0, off at tick 2048 (50% duty) pwm.SetPwm(0, 0, 2048); // Set duty cycle (0.0 = off, 1.0 = fully on) pwm.SetDuty(0, 0.5f); // 50% duty . | . Channel Range: 0-15 (16 channels total) . PWM Value Range: 0-4095 (12-bit resolution) . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#individual-channel-control",
    
    "relUrl": "/docs/configuration/#individual-channel-control"
  },"39": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Bulk Channel Control",
    "content": "Set all channels simultaneously: . | 1 2 . | // Set all channels to same PWM value pwm.SetAllPwm(0, 2048); // All channels at 50% duty . | . Use Case: Synchronized control of all outputs . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#bulk-channel-control",
    
    "relUrl": "/docs/configuration/#bulk-channel-control"
  },"40": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Register Map Reference",
    "content": "The driver abstracts register access, but understanding the register map helps with advanced usage: . | Register | Address | Purpose | . | MODE1 | 0x00 | Main configuration (reset, sleep, auto-increment) | . | MODE2 | 0x01 | Output configuration (open-drain, totem-pole, inversion) | . | SUBADR1-3 | 0x02-0x04 | Subaddress registers | . | ALLCALLADR | 0x05 | All-call I2C address | . | LED0_ON_L | 0x06 | Channel 0 ON time (low byte) | . | LED0_ON_H | 0x07 | Channel 0 ON time (high byte) | . | LED0_OFF_L | 0x08 | Channel 0 OFF time (low byte) | . | LED0_OFF_H | 0x09 | Channel 0 OFF time (high byte) | . | ‚Ä¶ | ‚Ä¶ | Channels 1-15 follow sequentially | . | ALL_LED_ON_L | 0xFA | All channels ON time (low byte) | . | ALL_LED_ON_H | 0xFB | All channels ON time (high byte) | . | ALL_LED_OFF_L | 0xFC | All channels OFF time (low byte) | . | ALL_LED_OFF_H | 0xFD | All channels OFF time (high byte) | . | PRE_SCALE | 0xFE | PWM frequency prescaler | . | TESTMODE | 0xFF | Test mode register | . Register Definitions: inc/pca9685.hpp (enum Register) . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#register-map-reference",
    
    "relUrl": "/docs/configuration/#register-map-reference"
  },"41": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Advanced Features",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#advanced-features",
    
    "relUrl": "/docs/configuration/#advanced-features"
  },"42": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Output Enable (OE) Pin",
    "content": "The OE pin provides hardware control over all outputs: . | HIGH: All outputs disabled (high-impedance) | LOW/Floating: All outputs enabled | . Note: The driver does not control the OE pin. You must handle it externally via GPIO if needed. ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#output-enable-oe-pin",
    
    "relUrl": "/docs/configuration/#output-enable-oe-pin"
  },"43": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Sleep Mode",
    "content": "The chip supports sleep mode for power saving. The driver handles sleep mode automatically when changing frequency (see SetPwmFreq() implementation). ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#sleep-mode",
    
    "relUrl": "/docs/configuration/#sleep-mode"
  },"44": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Auto-Increment",
    "content": "The chip supports auto-increment for efficient register access. The driver uses this feature internally for multi-byte writes. ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#auto-increment",
    
    "relUrl": "/docs/configuration/#auto-increment"
  },"45": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Runtime Configuration",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#runtime-configuration",
    
    "relUrl": "/docs/configuration/#runtime-configuration"
  },"46": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Initialization Sequence",
    "content": ". | Reset: Call Reset() to put device in known state | Set Frequency: Call SetPwmFreq() before setting channels | Configure Channels: Use SetPwm() or SetDuty() to control outputs | . Example: . | 1 2 3 . | pwm.Reset(); // Initialize pwm.SetPwmFreq(50.0f); // Set frequency pwm.SetDuty(0, 0.5f); // Configure channel . | . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#initialization-sequence",
    
    "relUrl": "/docs/configuration/#initialization-sequence"
  },"47": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Recommended Settings",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#recommended-settings",
    
    "relUrl": "/docs/configuration/#recommended-settings"
  },"48": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "For Servo Control",
    "content": "| 1 2 3 4 5 . | pwm.Reset(); pwm.SetPwmFreq(50.0f); // Standard servo frequency // Set servo to center position (1.5ms pulse) pwm.SetDuty(0, 0.075f); // 7.5% duty = 1.5ms / 20ms . | . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#for-servo-control",
    
    "relUrl": "/docs/configuration/#for-servo-control"
  },"49": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "For LED Dimming",
    "content": "| 1 2 3 4 5 6 7 8 . | pwm.Reset(); pwm.SetPwmFreq(1000.0f); // High frequency for smooth dimming // Fade LED on channel 0 for (float duty = 0.0f; duty &lt;= 1.0f; duty += 0.01f) { pwm.SetDuty(0, duty); delay(10); } . | . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#for-led-dimming",
    
    "relUrl": "/docs/configuration/#for-led-dimming"
  },"50": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "For Motor Control",
    "content": "| 1 2 3 4 5 . | pwm.Reset(); pwm.SetPwmFreq(200.0f); // Moderate frequency for motors // Set motor speed pwm.SetDuty(0, 0.75f); // 75% speed . | . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#for-motor-control",
    
    "relUrl": "/docs/configuration/#for-motor-control"
  },"51": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Next Steps",
    "content": ". | See Examples for configuration examples | Review API Reference for all configuration methods | Check Troubleshooting for configuration issues | . Navigation ‚¨ÖÔ∏è Platform Integration | Next: API Reference ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pca9685-driver/development/docs/configuration/#next-steps",
    
    "relUrl": "/docs/configuration/#next-steps"
  },"52": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "‚öôÔ∏è Configuration",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/configuration/",
    
    "relUrl": "/docs/configuration/"
  },"53": {
    "doc": "üí° Examples",
    "title": "Examples",
    "content": "This guide provides complete, working examples demonstrating various use cases for the PCA9685 driver. ",
    "url": "/hf-pca9685-driver/development/docs/examples/#examples",
    
    "relUrl": "/docs/examples/#examples"
  },"54": {
    "doc": "üí° Examples",
    "title": "Example 1: Basic Servo Control",
    "content": "This example shows how to control a standard servo motor using the PCA9685. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 . | #include \"pca9685.hpp\" #include \"driver/i2c.h\" // ESP32 I2C implementation class Esp32I2cBus : public pca9685::I2cInterface&lt;Esp32I2cBus&gt; { public: bool EnsureInitialized() noexcept { return true; } bool Write(uint8_t addr, uint8_t reg, const uint8_t* data, size_t len) noexcept { i2c_cmd_handle_t cmd = i2c_cmd_link_create(); i2c_master_start(cmd); i2c_master_write_byte(cmd, (addr &lt;&lt; 1) | I2C_MASTER_WRITE, true); i2c_master_write_byte(cmd, reg, true); i2c_master_write(cmd, (uint8_t*)data, len, true); i2c_master_stop(cmd); esp_err_t ret = i2c_master_cmd_begin(I2C_NUM_0, cmd, 1000 / portTICK_PERIOD_MS); i2c_cmd_link_delete(cmd); return ret == ESP_OK; } bool Read(uint8_t addr, uint8_t reg, uint8_t* data, size_t len) noexcept { i2c_cmd_handle_t cmd = i2c_cmd_link_create(); i2c_master_start(cmd); i2c_master_write_byte(cmd, (addr &lt;&lt; 1) | I2C_MASTER_WRITE, true); i2c_master_write_byte(cmd, reg, true); i2c_master_start(cmd); i2c_master_write_byte(cmd, (addr &lt;&lt; 1) | I2C_MASTER_READ, true); i2c_master_read(cmd, data, len, I2C_MASTER_LAST_NACK); i2c_master_stop(cmd); esp_err_t ret = i2c_master_cmd_begin(I2C_NUM_0, cmd, 1000 / portTICK_PERIOD_MS); i2c_cmd_link_delete(cmd); return ret == ESP_OK; } }; extern \"C\" void app_main() { // Initialize I2C (not shown - use your platform's I2C init) Esp32I2cBus i2c; pca9685::PCA9685&lt;Esp32I2cBus&gt; pwm(&amp;i2c, 0x40); // Initialize if (!pwm.Reset()) { printf(\"Failed to initialize PCA9685!\\n\"); return; } // Set frequency for servos (50 Hz) pwm.SetPwmFreq(50.0f); // Move servo to center position (1.5ms pulse = 7.5% duty at 50 Hz) pwm.SetDuty(0, 0.075f); // Move servo to 90 degrees (2.0ms pulse = 10% duty) pwm.SetDuty(0, 0.10f); // Move servo to 0 degrees (1.0ms pulse = 5% duty) pwm.SetDuty(0, 0.05f); printf(\"Servo control example complete.\\n\"); } . | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#example-1-basic-servo-control",
    
    "relUrl": "/docs/examples/#example-1-basic-servo-control"
  },"55": {
    "doc": "üí° Examples",
    "title": "Explanation",
    "content": ". | I2C Interface: Implement I2cInterface for your platform (ESP32 example shown) | Initialization: Call Reset() to initialize the device | Frequency: Set 50 Hz for standard servos (20ms period) | Duty Cycle: Use SetDuty() with values 0.05-0.10 for typical servo range . | 0.05 = 1.0ms pulse (0 degrees) | 0.075 = 1.5ms pulse (center/90 degrees) | 0.10 = 2.0ms pulse (180 degrees) | . | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#explanation",
    
    "relUrl": "/docs/examples/#explanation"
  },"56": {
    "doc": "üí° Examples",
    "title": "Expected Output",
    "content": "The servo should move to different positions as the duty cycle changes. ",
    "url": "/hf-pca9685-driver/development/docs/examples/#expected-output",
    
    "relUrl": "/docs/examples/#expected-output"
  },"57": {
    "doc": "üí° Examples",
    "title": "Example 2: LED Dimming",
    "content": "This example demonstrates smooth LED dimming using PWM. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 . | #include \"pca9685.hpp\" // ... I2C implementation (same as Example 1) ... void fade_led(pca9685::PCA9685&lt;Esp32I2cBus&gt;&amp; pwm, uint8_t channel) { // Set high frequency for smooth dimming (1 kHz) pwm.SetPwmFreq(1000.0f); // Fade in for (float duty = 0.0f; duty &lt;= 1.0f; duty += 0.01f) { pwm.SetDuty(channel, duty); vTaskDelay(pdMS_TO_TICKS(10)); // 10ms delay } // Fade out for (float duty = 1.0f; duty &gt;= 0.0f; duty -= 0.01f) { pwm.SetDuty(channel, duty); vTaskDelay(pdMS_TO_TICKS(10)); } } extern \"C\" void app_main() { Esp32I2cBus i2c; pca9685::PCA9685&lt;Esp32I2cBus&gt; pwm(&amp;i2c, 0x40); pwm.Reset(); // Fade LED on channel 0 fade_led(pwm, 0); } . | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#example-2-led-dimming",
    
    "relUrl": "/docs/examples/#example-2-led-dimming"
  },"58": {
    "doc": "üí° Examples",
    "title": "Explanation",
    "content": ". | High Frequency: Use 1 kHz for smooth LED dimming (avoids visible flicker) | Duty Cycle Sweep: Gradually change duty from 0.0 to 1.0 for fade effect | Timing: Small delays between updates create smooth transitions | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#explanation-1",
    
    "relUrl": "/docs/examples/#explanation-1"
  },"59": {
    "doc": "üí° Examples",
    "title": "Example 3: Multiple Channels",
    "content": "This example shows controlling multiple channels simultaneously. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 . | #include \"pca9685.hpp\" // ... I2C implementation ... extern \"C\" void app_main() { Esp32I2cBus i2c; pca9685::PCA9685&lt;Esp32I2cBus&gt; pwm(&amp;i2c, 0x40); pwm.Reset(); pwm.SetPwmFreq(1000.0f); // 1 kHz for LEDs // Set different duty cycles for different channels pwm.SetDuty(0, 0.25f); // Channel 0: 25% brightness pwm.SetDuty(1, 0.50f); // Channel 1: 50% brightness pwm.SetDuty(2, 0.75f); // Channel 2: 75% brightness pwm.SetDuty(3, 1.0f); // Channel 3: 100% brightness // Set all remaining channels to 50% for (uint8_t ch = 4; ch &lt; 16; ch++) { pwm.SetDuty(ch, 0.5f); } } . | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#example-3-multiple-channels",
    
    "relUrl": "/docs/examples/#example-3-multiple-channels"
  },"60": {
    "doc": "üí° Examples",
    "title": "Explanation",
    "content": "Each channel operates independently. You can set different duty cycles for each of the 16 channels. ",
    "url": "/hf-pca9685-driver/development/docs/examples/#explanation-2",
    
    "relUrl": "/docs/examples/#explanation-2"
  },"61": {
    "doc": "üí° Examples",
    "title": "Example 4: Error Handling",
    "content": "This example demonstrates proper error handling using the bitmask error model. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 . | #include \"pca9685.hpp\" // ... I2C implementation ... extern \"C\" void app_main() { Esp32I2cBus i2c; pca9685::PCA9685&lt;Esp32I2cBus&gt; pwm(&amp;i2c, 0x40); // Initialize with error checking if (!pwm.Reset()) { // Use GetErrorFlags() for bitmask-based error checking (uint16_t) uint16_t flags = pwm.GetErrorFlags(); printf(\"Reset failed: error flags 0x%04X\\n\", flags); // Or use GetLastError() as a convenience accessor auto error = pwm.GetLastError(); printf(\"Reset failed: error code %d\\n\", static_cast&lt;int&gt;(error)); return; } // Set frequency with validation if (!pwm.SetPwmFreq(50.0f)) { uint16_t flags = pwm.GetErrorFlags(); if (flags &amp; static_cast&lt;uint16_t&gt;(pca9685::PCA9685&lt;Esp32I2cBus&gt;::Error::OutOfRange)) { printf(\"Frequency out of range!\\n\"); } if (flags &amp; static_cast&lt;uint16_t&gt;(pca9685::PCA9685&lt;Esp32I2cBus&gt;::Error::I2cWrite)) { printf(\"I2C write failed!\\n\"); } pwm.ClearErrorFlags(flags); // Clear after handling return; } // Set channel with error checking if (!pwm.SetDuty(0, 0.5f)) { uint16_t flags = pwm.GetErrorFlags(); printf(\"SetDuty failed: error flags 0x%04X\\n\", flags); pwm.ClearErrorFlags(flags); } } . | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#example-4-error-handling",
    
    "relUrl": "/docs/examples/#example-4-error-handling"
  },"62": {
    "doc": "üí° Examples",
    "title": "Explanation",
    "content": "Error flags are now uint16_t bitmask values: . | I2cWrite = 1&lt;&lt;0, I2cRead = 1&lt;&lt;1, InvalidParam = 1&lt;&lt;2 | DeviceNotFound = 1&lt;&lt;3, NotInitialized = 1&lt;&lt;4, OutOfRange = 1&lt;&lt;5 | . Use GetErrorFlags() to retrieve all accumulated error flags, and ClearErrorFlags(mask) to clear them after handling. The convenience accessor GetLastError() still works for simple cases. Multiple error conditions can be set simultaneously since flags are a bitmask. ",
    "url": "/hf-pca9685-driver/development/docs/examples/#explanation-3",
    
    "relUrl": "/docs/examples/#explanation-3"
  },"63": {
    "doc": "üí° Examples",
    "title": "Example 5: Bulk Channel Update",
    "content": "This example shows efficient bulk updates using SetAllPwm(). | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 . | #include \"pca9685.hpp\" // ... I2C implementation ... extern \"C\" void app_main() { Esp32I2cBus i2c; pca9685::PCA9685&lt;Esp32I2cBus&gt; pwm(&amp;i2c, 0x40); pwm.Reset(); pwm.SetPwmFreq(1000.0f); // Turn all channels on to 50% simultaneously pwm.SetAllPwm(0, 2048); // Turn all channels off pwm.SetAllPwm(0, 0); // Turn all channels fully on pwm.SetAllPwm(0, 4095); } . | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#example-5-bulk-channel-update",
    
    "relUrl": "/docs/examples/#example-5-bulk-channel-update"
  },"64": {
    "doc": "üí° Examples",
    "title": "Explanation",
    "content": "SetAllPwm() is more efficient than calling SetPwm() 16 times. It writes to the ALL_LED registers, updating all channels in a single I2C transaction. ",
    "url": "/hf-pca9685-driver/development/docs/examples/#explanation-4",
    
    "relUrl": "/docs/examples/#explanation-4"
  },"65": {
    "doc": "üí° Examples",
    "title": "Example 6: Power Management and Output Modes",
    "content": "This example demonstrates the power management and output configuration features. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 . | #include \"pca9685.hpp\" // ... I2C implementation ... extern \"C\" void app_main() { Esp32I2cBus i2c; pca9685::PCA9685&lt;Esp32I2cBus&gt; pwm(&amp;i2c, 0x40); pwm.Reset(); pwm.SetPwmFreq(1000.0f); // Configure retry count for I2C operations (default is 3) pwm.SetRetries(3); // Configure output driver mode (true = totem-pole, false = open-drain) pwm.SetOutputDriverMode(true); // Optionally invert outputs pwm.SetOutputInvert(false); // Set some channels pwm.SetDuty(0, 0.5f); // Use full ON/OFF without PWM pwm.SetChannelFullOn(1); // Channel 1 fully on pwm.SetChannelFullOff(2); // Channel 2 fully off // Power management: put device to sleep pwm.Sleep(); // ... device is in low-power mode ... // Wake up and resume pwm.Wake(); // Outputs resume from where they were } . | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#example-6-power-management-and-output-modes",
    
    "relUrl": "/docs/examples/#example-6-power-management-and-output-modes"
  },"66": {
    "doc": "üí° Examples",
    "title": "Explanation",
    "content": ". | SetRetries(): Configures how many times I2C operations are retried on failure (default 3) | SetOutputDriverMode(): Selects totem-pole (true) or open-drain (false) output via MODE2 OUTDRV bit | SetOutputInvert(): Inverts output logic via MODE2 INVRT bit | SetChannelFullOn() / SetChannelFullOff(): Sets a channel fully on or off without PWM | Sleep() / Wake(): Controls the MODE1 SLEEP bit for low-power mode | . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#explanation-5",
    
    "relUrl": "/docs/examples/#explanation-5"
  },"67": {
    "doc": "üí° Examples",
    "title": "Running the Examples",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/examples/#running-the-examples",
    
    "relUrl": "/docs/examples/#running-the-examples"
  },"68": {
    "doc": "üí° Examples",
    "title": "ESP32 Applications",
    "content": "The ESP32 example project provides two applications, built and flashed via scripts (not raw idf.py): . | Application | Description | . | pca9685_comprehensive_test | Full driver test suite: init, frequency, PWM, duty cycle, all-channel control, prescale readback, sleep/wake, output config, error handling, stress tests (12 tests total). | . | pca9685_servo_demo | 16-channel hobby servo demo: 1000‚Äì2000 ¬µs pulse, velocity-limited motion, synchronized animations (Wave, Breathe, Cascade, Mirror, etc.). | . Prerequisites: ESP-IDF (e.g. release/v5.5), target e.g. esp32s3. From the repo root: . | 1 2 3 4 . | cd examples/esp32 chmod +x scripts/*.sh ./scripts/setup_repo.sh # first time only ./scripts/build_app.sh list . | . Build: . | 1 2 3 . | ./scripts/build_app.sh pca9685_comprehensive_test Debug # or ./scripts/build_app.sh pca9685_servo_demo Debug . | . Flash and monitor: . | 1 2 3 . | ./scripts/flash_app.sh flash_monitor pca9685_comprehensive_test Debug # or ./scripts/flash_app.sh flash_monitor pca9685_servo_demo Debug . | . I2C pins: Default SDA=GPIO4, SCL=GPIO5. Override at configure time if needed: . | 1 2 . | ./scripts/build_app.sh pca9685_comprehensive_test Debug \\ -- -DPCA9685_EXAMPLE_I2C_SDA_GPIO=8 -DPCA9685_EXAMPLE_I2C_SCL_GPIO=9 . | . See examples/esp32/README.md and examples/esp32/docs/ for hardware setup and app details. ",
    "url": "/hf-pca9685-driver/development/docs/examples/#esp32-applications",
    
    "relUrl": "/docs/examples/#esp32-applications"
  },"69": {
    "doc": "üí° Examples",
    "title": "Other Platforms",
    "content": "Adapt the I2C interface implementation for your platform (see Platform Integration) and compile with your platform‚Äôs toolchain. The ESP32 implementation in examples/esp32/main/esp32_pca9685_bus.hpp uses ESP-IDF‚Äôs driver/i2c_master.h (new I2C master API) as a reference. ",
    "url": "/hf-pca9685-driver/development/docs/examples/#other-platforms",
    
    "relUrl": "/docs/examples/#other-platforms"
  },"70": {
    "doc": "üí° Examples",
    "title": "Next Steps",
    "content": ". | Review the API Reference for method details | Check Troubleshooting if you encounter issues | Explore the examples directory for more examples | . Navigation ‚¨ÖÔ∏è API Reference | Next: Troubleshooting ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pca9685-driver/development/docs/examples/#next-steps",
    
    "relUrl": "/docs/examples/#next-steps"
  },"71": {
    "doc": "üí° Examples",
    "title": "üí° Examples",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/examples/",
    
    "relUrl": "/docs/examples/"
  },"72": {
    "doc": "üîå Hardware Setup",
    "title": "Hardware Setup",
    "content": "This guide covers the physical connections and hardware requirements for the PCA9685 chip. ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#hardware-setup",
    
    "relUrl": "/docs/hardware_setup/#hardware-setup"
  },"73": {
    "doc": "üîå Hardware Setup",
    "title": "Pin Connections",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#pin-connections",
    
    "relUrl": "/docs/hardware_setup/#pin-connections"
  },"74": {
    "doc": "üîå Hardware Setup",
    "title": "Basic I2C Connections",
    "content": "| 1 2 3 4 5 6 . | MCU PCA9685 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ VDD GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ GND SCL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SCL (with 4.7kŒ© pull-up to 3.3V) SDA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SDA (with 4.7kŒ© pull-up to 3.3V) . | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#basic-i2c-connections",
    
    "relUrl": "/docs/hardware_setup/#basic-i2c-connections"
  },"75": {
    "doc": "üîå Hardware Setup",
    "title": "Pin Descriptions",
    "content": "| Pin | Name | Description | Required | . | VDD | Power | 2.3V to 5.5V power supply (typically 3.3V or 5V) | Yes | . | GND | Ground | Ground reference | Yes | . | SCL | Clock | I2C clock line | Yes | . | SDA | Data | I2C data line | Yes | . | OE | Output Enable | Active-low output enable (optional) | No | . | A0-A5 | Address | I2C address selection pins | No (for single device) | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#pin-descriptions",
    
    "relUrl": "/docs/hardware_setup/#pin-descriptions"
  },"76": {
    "doc": "üîå Hardware Setup",
    "title": "Output Channels",
    "content": "The PCA9685 provides 16 PWM output channels (OUT0-OUT15). Each channel can drive: . | LEDs (with current-limiting resistors) | Servos (typically 5V servos) | Other PWM-controlled devices | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#output-channels",
    
    "relUrl": "/docs/hardware_setup/#output-channels"
  },"77": {
    "doc": "üîå Hardware Setup",
    "title": "Power Requirements",
    "content": ". | Supply Voltage: 2.3V to 5.5V (3.3V or 5V typical) | Current Consumption: . | Active: ~10 mA typical | Sleep mode: &lt; 1 ¬µA | . | Power Supply: Stable, low-noise supply recommended | Decoupling: 100 nF ceramic capacitor close to VDD pin recommended | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#power-requirements",
    
    "relUrl": "/docs/hardware_setup/#power-requirements"
  },"78": {
    "doc": "üîå Hardware Setup",
    "title": "I2C Configuration",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#i2c-configuration",
    
    "relUrl": "/docs/hardware_setup/#i2c-configuration"
  },"79": {
    "doc": "üîå Hardware Setup",
    "title": "Address Configuration",
    "content": "The PCA9685 I2C address is determined by pins A0-A5: . | A5 | A4 | A3 | A2 | A1 | A0 | I2C Address (7-bit) | . | 0 | 0 | 0 | 0 | 0 | 0 | 0x40 (default) | . | 0 | 0 | 0 | 0 | 0 | 1 | 0x41 | . | ‚Ä¶ | ‚Ä¶ | ‚Ä¶ | ‚Ä¶ | ‚Ä¶ | ‚Ä¶ | ‚Ä¶ | . | 1 | 1 | 1 | 1 | 1 | 1 | 0x7F | . Default: All address pins to GND = 0x40 (used in examples) . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#address-configuration",
    
    "relUrl": "/docs/hardware_setup/#address-configuration"
  },"80": {
    "doc": "üîå Hardware Setup",
    "title": "I2C Bus Configuration",
    "content": ". | Speed: Up to 1 MHz (Fast Mode Plus) . | Standard Mode: 100 kHz | Fast Mode: 400 kHz (most common) | Fast Mode Plus: 1 MHz | . | Pull-up Resistors: 4.7 kŒ© on SCL and SDA (required for I2C) | Bus Voltage: Must match VDD (3.3V or 5V) | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#i2c-bus-configuration",
    
    "relUrl": "/docs/hardware_setup/#i2c-bus-configuration"
  },"81": {
    "doc": "üîå Hardware Setup",
    "title": "Physical Layout Recommendations",
    "content": ". | Trace Length: Keep I2C traces short (&lt; 10 cm recommended for high speeds) | Ground Plane: Use a ground plane for noise reduction | Decoupling: Place 100 nF ceramic capacitor within 1 cm of VDD pin | Routing: Route clock and data lines away from noise sources (switching regulators, motors) | Multiple Devices: When daisy-chaining, use proper bus termination | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#physical-layout-recommendations",
    
    "relUrl": "/docs/hardware_setup/#physical-layout-recommendations"
  },"82": {
    "doc": "üîå Hardware Setup",
    "title": "Example Wiring Diagram",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#example-wiring-diagram",
    
    "relUrl": "/docs/hardware_setup/#example-wiring-diagram"
  },"83": {
    "doc": "üîå Hardware Setup",
    "title": "Single PCA9685",
    "content": "| 1 2 3 4 5 6 7 8 9 . | PCA9685 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ VDD ‚îÇ GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ GND ‚îÇ SCL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SCL ‚îÇ‚îÄ‚îÄ‚îÄ 4.7kŒ© ‚îÄ‚îÄ‚îÄ 3.3V SDA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SDA ‚îÇ‚îÄ‚îÄ‚îÄ 4.7kŒ© ‚îÄ‚îÄ‚îÄ 3.3V ‚îÇ ‚îÇ ‚îÇ OUT0-15 ‚îÇ‚îÄ‚îÄ‚îÄ To LEDs/Servos ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò . | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#single-pca9685",
    
    "relUrl": "/docs/hardware_setup/#single-pca9685"
  },"84": {
    "doc": "üîå Hardware Setup",
    "title": "Multiple PCA9685 Devices (Daisy Chain)",
    "content": "| 1 2 3 4 5 6 7 . | MCU SCL ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ PCA9685 #1 (A0=0, Addr=0x40) SCL ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ PCA9685 #2 (A0=1, Addr=0x41) SCL MCU SDA ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ PCA9685 #1 SDA ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ PCA9685 #2 SDA . | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#multiple-pca9685-devices-daisy-chain",
    
    "relUrl": "/docs/hardware_setup/#multiple-pca9685-devices-daisy-chain"
  },"85": {
    "doc": "üîå Hardware Setup",
    "title": "Output Enable (OE) Pin",
    "content": "The OE pin is an active-low output enable. When pulled HIGH, all outputs are disabled (high-impedance). When pulled LOW or left floating, outputs are enabled. Typical Usage: . | Connect to a GPIO for software control | Leave floating if not needed (internal pull-up enables outputs) | Use for synchronized startup of multiple devices | . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#output-enable-oe-pin",
    
    "relUrl": "/docs/hardware_setup/#output-enable-oe-pin"
  },"86": {
    "doc": "üîå Hardware Setup",
    "title": "Next Steps",
    "content": ". | Verify connections with a multimeter | Use an I2C scanner to verify device detection at expected address | Proceed to Quick Start to test the connection | Review Platform Integration for software setup | . Navigation ‚¨ÖÔ∏è Quick Start | Next: Platform Integration ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/#next-steps",
    
    "relUrl": "/docs/hardware_setup/#next-steps"
  },"87": {
    "doc": "üîå Hardware Setup",
    "title": "üîå Hardware Setup",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/hardware_setup/",
    
    "relUrl": "/docs/hardware_setup/"
  },"88": {
    "doc": "üìö Documentation",
    "title": "HF-PCA9685 Documentation",
    "content": "Welcome! This directory contains step-by-step guides for installing, building, and using the HF-PCA9685 library. ",
    "url": "/hf-pca9685-driver/development/docs/#hf-pca9685-documentation",
    
    "relUrl": "/docs/#hf-pca9685-documentation"
  },"89": {
    "doc": "üìö Documentation",
    "title": "üìö Documentation Structure",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/#-documentation-structure",
    
    "relUrl": "/docs/#-documentation-structure"
  },"90": {
    "doc": "üìö Documentation",
    "title": "Getting Started",
    "content": ". | üõ†Ô∏è Installation ‚Äì Prerequisites and how to obtain the source | ‚ö° Quick Start ‚Äì Minimal working example to get you running | üîå Hardware Setup ‚Äì Wiring diagrams and pin connections | . ",
    "url": "/hf-pca9685-driver/development/docs/#getting-started",
    
    "relUrl": "/docs/#getting-started"
  },"91": {
    "doc": "üìö Documentation",
    "title": "Integration",
    "content": ". | üîß Platform Integration ‚Äì Implement the CRTP bus interface for your platform | ‚öôÔ∏è Configuration ‚Äì Configuration options and settings | . ",
    "url": "/hf-pca9685-driver/development/docs/#integration",
    
    "relUrl": "/docs/#integration"
  },"92": {
    "doc": "üìö Documentation",
    "title": "Reference",
    "content": ". | üìñ API Reference ‚Äì Complete API documentation | üí° Examples ‚Äì Detailed example walkthroughs (code snippets + ESP32 app list) | . ",
    "url": "/hf-pca9685-driver/development/docs/#reference",
    
    "relUrl": "/docs/#reference"
  },"93": {
    "doc": "üìö Documentation",
    "title": "ESP32 Applications",
    "content": ". | ESP32 apps ‚Äì Index ¬∑ Comprehensive test ¬∑ Servo demo (build, run, customize) | . ",
    "url": "/hf-pca9685-driver/development/docs/#esp32-applications",
    
    "relUrl": "/docs/#esp32-applications"
  },"94": {
    "doc": "üìö Documentation",
    "title": "Troubleshooting",
    "content": ". | üêõ Troubleshooting ‚Äì Common issues and solutions | . ",
    "url": "/hf-pca9685-driver/development/docs/#troubleshooting",
    
    "relUrl": "/docs/#troubleshooting"
  },"95": {
    "doc": "üìö Documentation",
    "title": "üöÄ Quick Start Path",
    "content": "New to PCA9685? Follow this recommended path: . | Start with Installation to prepare your environment | Follow Hardware Setup to wire your hardware | Read Quick Start for a minimal working example | Check Platform Integration to implement the interface | Explore Examples for more advanced usage | . ",
    "url": "/hf-pca9685-driver/development/docs/#-quick-start-path",
    
    "relUrl": "/docs/#-quick-start-path"
  },"96": {
    "doc": "üìö Documentation",
    "title": "üí° Need Help?",
    "content": ". | üêõ Found a bug? Check the Troubleshooting guide | ‚ùì Have questions? Review the API Reference | üìù Want to contribute? See the contributing guidelines in the main README | . Navigation ‚û°Ô∏è Installation . ",
    "url": "/hf-pca9685-driver/development/docs/#-need-help",
    
    "relUrl": "/docs/#-need-help"
  },"97": {
    "doc": "üìö Documentation",
    "title": "üìö Documentation",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/",
    
    "relUrl": "/docs/"
  },"98": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Installation",
    "content": "This guide covers how to obtain, build, and verify the PCA9685 driver library. ",
    "url": "/hf-pca9685-driver/development/docs/installation/#installation",
    
    "relUrl": "/docs/installation/#installation"
  },"99": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Prerequisites",
    "content": "Before installing the driver, ensure you have: . | C++11 Compiler: GCC 4.8+, Clang 3.3+, or MSVC 2013+ | Build System: Make or CMake (optional, for building static library) | Platform SDK: Your platform‚Äôs I2C driver (ESP-IDF, STM32 HAL, Arduino Wire, etc.) | . ",
    "url": "/hf-pca9685-driver/development/docs/installation/#prerequisites",
    
    "relUrl": "/docs/installation/#prerequisites"
  },"100": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Obtaining the Source",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/installation/#obtaining-the-source",
    
    "relUrl": "/docs/installation/#obtaining-the-source"
  },"101": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Option 1: Git Clone",
    "content": "| 1 2 . | git clone https://github.com/N3b3x/hf-pca9685-driver.git cd hf-pca9685-driver . | . ",
    "url": "/hf-pca9685-driver/development/docs/installation/#option-1-git-clone",
    
    "relUrl": "/docs/installation/#option-1-git-clone"
  },"102": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Option 2: Copy Files",
    "content": "Copy the following files into your project: . | 1 2 3 4 5 . | inc/ ‚îú‚îÄ‚îÄ pca9685.hpp ‚îî‚îÄ‚îÄ pca9685_i2c_interface.hpp src/ ‚îî‚îÄ‚îÄ pca9685.ipp . | . Note: The driver uses a template design: the implementation is in src/pca9685.ipp and is included by inc/pca9685.hpp. Your build must have inc/ and src/ on the include path so that pca9685.hpp can include the .ipp file. You do not compile pca9685.ipp as a separate translation unit. ",
    "url": "/hf-pca9685-driver/development/docs/installation/#option-2-copy-files",
    
    "relUrl": "/docs/installation/#option-2-copy-files"
  },"103": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Building the Library",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/installation/#building-the-library",
    
    "relUrl": "/docs/installation/#building-the-library"
  },"104": {
    "doc": "üõ†Ô∏è Installation",
    "title": "As Part of Your Project (Include Path)",
    "content": "Since the driver is header-only (template implementation in .ipp), add the repository inc/ and src/ directories to your include path and include the main header: . | 1 . | #include \"pca9685.hpp\" . | . Your build system must allow the header to find ../src/pca9685.ipp (relative to the header) or you can add src/ to the include path as well. ",
    "url": "/hf-pca9685-driver/development/docs/installation/#as-part-of-your-project-include-path",
    
    "relUrl": "/docs/installation/#as-part-of-your-project-include-path"
  },"105": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Using CMake",
    "content": "| 1 2 3 4 5 6 . | # Include path must include both inc and src (for .ipp include from header) target_include_directories(your_target PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/hf-pca9685-driver/inc ${CMAKE_CURRENT_SOURCE_DIR}/hf-pca9685-driver/src ) # No separate library: template is instantiated in your code . | . ",
    "url": "/hf-pca9685-driver/development/docs/installation/#using-cmake",
    
    "relUrl": "/docs/installation/#using-cmake"
  },"106": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Using ESP-IDF (ESP32 Examples)",
    "content": "The driver is provided as an ESP-IDF component in the ESP32 examples. Build and flash using the example scripts: . | 1 2 3 4 . | cd examples/esp32 ./scripts/build_app.sh list # List available apps ./scripts/build_app.sh pca9685_comprehensive_test Debug ./scripts/flash_app.sh flash_monitor pca9685_comprehensive_test Debug . | . See examples/esp32/README.md and examples/esp32/docs/ for full setup and app descriptions. ",
    "url": "/hf-pca9685-driver/development/docs/installation/#using-esp-idf-esp32-examples",
    
    "relUrl": "/docs/installation/#using-esp-idf-esp32-examples"
  },"107": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Verification",
    "content": "To verify the installation: . | Include the header in a test file: | 1 2 . | #include \"pca9685.hpp\" // Provide an I2C implementation and instantiate PCA9685&lt;YourI2c&gt; . | . | Ensure your include path contains both inc/ and src/ (so pca9685.hpp can include pca9685.ipp). | For hardware verification, use the ESP32 comprehensive test app (see Examples): | 1 2 3 . | cd examples/esp32 ./scripts/build_app.sh pca9685_comprehensive_test Debug ./scripts/flash_app.sh flash_monitor pca9685_comprehensive_test Debug . | . All 12 tests should pass when the PCA9685 is connected at 0x40 on the configured I2C pins. | . ",
    "url": "/hf-pca9685-driver/development/docs/installation/#verification",
    
    "relUrl": "/docs/installation/#verification"
  },"108": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Next Steps",
    "content": ". | Follow the Quick Start guide to create your first application | Review Hardware Setup for wiring instructions | Check Platform Integration to implement the I2C interface | . Navigation ‚¨ÖÔ∏è Back to Index | Next: Quick Start ‚û°Ô∏è . ",
    "url": "/hf-pca9685-driver/development/docs/installation/#next-steps",
    
    "relUrl": "/docs/installation/#next-steps"
  },"109": {
    "doc": "üõ†Ô∏è Installation",
    "title": "üõ†Ô∏è Installation",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/installation/",
    
    "relUrl": "/docs/installation/"
  },"110": {
    "doc": "üîß Platform Integration",
    "title": "Platform Integration Guide",
    "content": "This guide explains how to implement the hardware abstraction interface for the PCA9685 driver on your platform. ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#platform-integration-guide",
    
    "relUrl": "/docs/platform_integration/#platform-integration-guide"
  },"111": {
    "doc": "üîß Platform Integration",
    "title": "Understanding CRTP (Curiously Recurring Template Pattern)",
    "content": "The PCA9685 driver uses CRTP (Curiously Recurring Template Pattern) for hardware abstraction. This design choice provides several critical benefits for embedded systems: . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#understanding-crtp-curiously-recurring-template-pattern",
    
    "relUrl": "/docs/platform_integration/#understanding-crtp-curiously-recurring-template-pattern"
  },"112": {
    "doc": "üîß Platform Integration",
    "title": "Why CRTP Instead of Virtual Functions?",
    "content": "1. Zero Runtime Overhead . | Virtual functions: Require a vtable lookup (indirect call) = ~5-10 CPU cycles overhead per call | CRTP: Direct function calls = 0 overhead, compiler can inline | Impact: In time-critical embedded code, this matters significantly | . 2. Compile-Time Polymorphism . | Virtual functions: Runtime dispatch - the compiler cannot optimize across the abstraction boundary | CRTP: Compile-time dispatch - full optimization, dead code elimination, constant propagation | Impact: Smaller code size, faster execution | . 3. Memory Efficiency . | Virtual functions: Each object needs a vtable pointer (4-8 bytes) | CRTP: No vtable pointer needed | Impact: Critical in memory-constrained systems (many MCUs have &lt;64KB RAM) | . 4. Type Safety . | Virtual functions: Runtime errors if method not implemented | CRTP: Compile-time errors if method not implemented | Impact: Catch bugs at compile time, not in the field | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#why-crtp-instead-of-virtual-functions",
    
    "relUrl": "/docs/platform_integration/#why-crtp-instead-of-virtual-functions"
  },"113": {
    "doc": "üîß Platform Integration",
    "title": "How CRTP Works",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 . | // Base template class (from pca9685_i2c_interface.hpp) template &lt;typename Derived&gt; class I2cInterface { public: bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept { // Cast 'this' to Derived* and call the derived implementation return static_cast&lt;Derived*&gt;(this)-&gt;Write(addr, reg, data, len); } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept { return static_cast&lt;Derived*&gt;(this)-&gt;Read(addr, reg, data, len); } bool EnsureInitialized() noexcept { return static_cast&lt;Derived*&gt;(this)-&gt;EnsureInitialized(); } }; // Your implementation class MyI2c : public pca9685::I2cInterface&lt;MyI2c&gt; { public: // This method is called directly (no virtual overhead) bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept { // Your platform-specific I2C code } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept { // Your platform-specific I2C code } bool EnsureInitialized() noexcept { // Lazy-initialize your I2C bus } }; . | . The key insight: static_cast&lt;Derived*&gt;(this) allows the base class to call methods on the derived class at compile time, not runtime. ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#how-crtp-works",
    
    "relUrl": "/docs/platform_integration/#how-crtp-works"
  },"114": {
    "doc": "üîß Platform Integration",
    "title": "Performance Comparison",
    "content": "| Aspect | Virtual Functions | CRTP | . | Function call overhead | ~5-10 cycles | 0 cycles (inlined) | . | Code size | Larger (vtables) | Smaller (optimized) | . | Memory per object | +4-8 bytes (vptr) | 0 bytes | . | Compile-time checks | No | Yes | . | Optimization | Limited | Full | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#performance-comparison",
    
    "relUrl": "/docs/platform_integration/#performance-comparison"
  },"115": {
    "doc": "üîß Platform Integration",
    "title": "Interface Definition",
    "content": "The PCA9685 driver requires you to implement the I2cInterface template: . Location: inc/pca9685_i2c_interface.hpp (interface); driver class in inc/pca9685.hpp . | 1 2 3 4 5 6 7 8 . | template &lt;typename Derived&gt; class I2cInterface { public: // Required methods (implement all three) bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept; bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept; bool EnsureInitialized() noexcept; }; . | . Note: I2cInterface is non-copyable and non-movable; use references or pointers to your concrete bus type. Method Requirements: . | Write(): Write len bytes from data to register reg at I2C address addr (7-bit address) | Read(): Read len bytes into data from register reg at I2C address addr (7-bit address) | EnsureInitialized(): Lazy-initialize the I2C bus; return true if ready | Write/Read return true on success, false on failure (NACK, timeout, etc.) | . Optional retry delay: The driver can call an optional callback between I2C retries for bus recovery. Your bus class can expose a static delay (e.g. static void RetryDelay() noexcept { vTaskDelay(pdMS_TO_TICKS(1)); }). After constructing the driver, the application calls driver-&gt;SetRetryDelay(MyBus::RetryDelay). If not set, no delay is used between retries. ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#interface-definition",
    
    "relUrl": "/docs/platform_integration/#interface-definition"
  },"116": {
    "doc": "üîß Platform Integration",
    "title": "Implementation Steps",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#implementation-steps",
    
    "relUrl": "/docs/platform_integration/#implementation-steps"
  },"117": {
    "doc": "üîß Platform Integration",
    "title": "Step 1: Create Your Implementation Class",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 . | #include \"pca9685.hpp\" class MyPlatformI2c : public pca9685::I2cInterface&lt;MyPlatformI2c&gt; { private: // Your platform-specific members i2c_handle_t i2c_handle_; bool initialized_ = false; public: // Constructor MyPlatformI2c(i2c_handle_t handle) : i2c_handle_(handle) {} // Implement required methods (NO virtual keyword!) bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept { // Your I2C write implementation return true; } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept { // Your I2C read implementation return true; } bool EnsureInitialized() noexcept { if (initialized_) return true; // Initialize I2C hardware... initialized_ = true; return true; } }; . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#step-1-create-your-implementation-class",
    
    "relUrl": "/docs/platform_integration/#step-1-create-your-implementation-class"
  },"118": {
    "doc": "üîß Platform Integration",
    "title": "Step 2: Platform-Specific Examples",
    "content": "ESP32 (ESP-IDF) . Location: See examples/esp32/main/esp32_pca9685_bus.hpp for a complete ESP32 implementation using ESP-IDF‚Äôs I2C master driver API. For a complete working example, see examples/esp32/main/pca9685_comprehensive_test.cpp. | 1 2 3 4 5 6 7 8 9 10 11 12 13 . | #include \"driver/i2c_master.h\" #include \"pca9685.hpp\" #include \"esp32_pca9685_bus.hpp\" // Use the provided ESP32 bus implementation auto i2c_bus = CreateEsp32Pca9685Bus(); pca9685::PCA9685&lt;Esp32Pca9685Bus&gt; pwm(i2c_bus.get(), 0x40); // Initialize if (!pwm.Reset()) { // Handle error return; } . | . STM32 (HAL) . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 . | #include \"stm32f4xx_hal.h\" #include \"pca9685.hpp\" extern I2C_HandleTypeDef hi2c1; class STM32I2cBus : public pca9685::I2cInterface&lt;STM32I2cBus&gt; { public: bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept { // STM32 HAL uses 8-bit address (7-bit &lt;&lt; 1) return HAL_I2C_Mem_Write(&amp;hi2c1, addr &lt;&lt; 1, reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)data, len, HAL_MAX_DELAY) == HAL_OK; } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept { return HAL_I2C_Mem_Read(&amp;hi2c1, addr &lt;&lt; 1, reg, I2C_MEMADD_SIZE_8BIT, data, len, HAL_MAX_DELAY) == HAL_OK; } bool EnsureInitialized() noexcept { return true; /* HAL_I2C_Init done elsewhere */ } }; . | . Arduino . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 . | #include &lt;Wire.h&gt; #include \"pca9685.hpp\" class ArduinoI2cBus : public pca9685::I2cInterface&lt;ArduinoI2cBus&gt; { public: bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept { Wire.beginTransmission(addr); Wire.write(reg); Wire.write(data, len); return Wire.endTransmission() == 0; } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept { Wire.beginTransmission(addr); Wire.write(reg); if (Wire.endTransmission(false) != 0) return false; Wire.requestFrom(addr, len); for (size_t i = 0; i &lt; len &amp;&amp; Wire.available(); i++) { data[i] = Wire.read(); } return true; } bool EnsureInitialized() noexcept { Wire.begin(); return true; } }; . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#step-2-platform-specific-examples",
    
    "relUrl": "/docs/platform_integration/#step-2-platform-specific-examples"
  },"119": {
    "doc": "üîß Platform Integration",
    "title": "Common Pitfalls",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#common-pitfalls",
    
    "relUrl": "/docs/platform_integration/#common-pitfalls"
  },"120": {
    "doc": "üîß Platform Integration",
    "title": "‚ùå Don‚Äôt Use Virtual Functions",
    "content": "| 1 2 3 4 5 6 7 . | // WRONG - defeats the purpose of CRTP class MyI2c : public pca9685::I2cInterface&lt;MyI2c&gt; { public: virtual bool Write(...) override { // ‚ùå Virtual keyword not needed // ... } }; . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#-dont-use-virtual-functions",
    
    "relUrl": "/docs/platform_integration/#-dont-use-virtual-functions"
  },"121": {
    "doc": "üîß Platform Integration",
    "title": "‚úÖ Correct CRTP Implementation",
    "content": "| 1 2 3 4 5 6 7 . | // CORRECT - no virtual keyword, PascalCase, noexcept class MyI2c : public pca9685::I2cInterface&lt;MyI2c&gt; { public: bool Write(...) noexcept { // ‚úÖ Direct implementation // ... } }; . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#-correct-crtp-implementation",
    
    "relUrl": "/docs/platform_integration/#-correct-crtp-implementation"
  },"122": {
    "doc": "üîß Platform Integration",
    "title": "‚ùå Don‚Äôt Forget the Template Parameter",
    "content": "| 1 2 3 4 . | // WRONG - missing template parameter class MyI2c : public pca9685::I2cInterface { // ‚ùå Compiler error // ... }; . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#-dont-forget-the-template-parameter",
    
    "relUrl": "/docs/platform_integration/#-dont-forget-the-template-parameter"
  },"123": {
    "doc": "üîß Platform Integration",
    "title": "‚úÖ Correct Template Parameter",
    "content": "| 1 2 3 4 . | // CORRECT - pass your class as template parameter class MyI2c : public pca9685::I2cInterface&lt;MyI2c&gt; { // ‚úÖ // ... }; . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#-correct-template-parameter",
    
    "relUrl": "/docs/platform_integration/#-correct-template-parameter"
  },"124": {
    "doc": "üîß Platform Integration",
    "title": "‚ùå Address Format Confusion",
    "content": "The driver uses 7-bit I2C addresses. Some platforms use 8-bit addresses (7-bit ¬´¬†1): . | 1 2 3 4 5 . | // WRONG - if your platform uses 8-bit addresses i2c_write(addr, ...); // ‚ùå Should be addr &lt;&lt; 1 // CORRECT i2c_write(addr &lt;&lt; 1, ...); // ‚úÖ Convert 7-bit to 8-bit . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#-address-format-confusion",
    
    "relUrl": "/docs/platform_integration/#-address-format-confusion"
  },"125": {
    "doc": "üîß Platform Integration",
    "title": "Testing Your Implementation",
    "content": "After implementing the interface, test it: . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . | MyPlatformI2c i2c; pca9685::PCA9685&lt;MyPlatformI2c&gt; pwm(&amp;i2c, 0x40); if (pwm.Reset()) { // Interface works! pwm.SetPwmFreq(50.0f); pwm.SetDuty(0, 0.5f); } else { // Check error flags (uint16_t bitmask) auto flags = pwm.GetErrorFlags(); // Or use convenience accessor: auto error = pwm.GetLastError(); // Debug your I2C implementation pwm.ClearErrorFlags(flags); // Clear after handling } . | . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#testing-your-implementation",
    
    "relUrl": "/docs/platform_integration/#testing-your-implementation"
  },"126": {
    "doc": "üîß Platform Integration",
    "title": "Next Steps",
    "content": ". | See Configuration for driver configuration options | Check Examples for complete usage examples | Review API Reference for all available methods | . Navigation ‚¨ÖÔ∏è Hardware Setup | Next: Configuration ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/#next-steps",
    
    "relUrl": "/docs/platform_integration/#next-steps"
  },"127": {
    "doc": "üîß Platform Integration",
    "title": "üîß Platform Integration",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/platform_integration/",
    
    "relUrl": "/docs/platform_integration/"
  },"128": {
    "doc": "‚ö° Quick Start",
    "title": "Quick Start",
    "content": "This guide will get you up and running with the PCA9685 driver in just a few steps. ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#quick-start",
    
    "relUrl": "/docs/quickstart/#quick-start"
  },"129": {
    "doc": "‚ö° Quick Start",
    "title": "Prerequisites",
    "content": ". | Driver installed | Hardware wired | I2C interface implemented | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#prerequisites",
    
    "relUrl": "/docs/quickstart/#prerequisites"
  },"130": {
    "doc": "‚ö° Quick Start",
    "title": "Minimal Example",
    "content": "Here‚Äôs a complete working example: . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 . | #include \"pca9685.hpp\" // 1. Implement the I2C interface class MyI2c : public pca9685::I2cInterface&lt;MyI2c&gt; { public: bool EnsureInitialized() noexcept { return true; } bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept { // Your I2C write implementation return true; } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept { // Your I2C read implementation return true; } }; // 2. Create instances MyI2c i2c; pca9685::PCA9685&lt;MyI2c&gt; pwm(&amp;i2c, 0x40); // 0x40 is default I2C address // 3. Initialize if (!pwm.Reset()) { // Handle initialization error return; } // 4. Set PWM frequency (required before setting channels) pwm.SetPwmFreq(50.0f); // 50 Hz for servos // 5. Set channel 0 to 50% duty cycle pwm.SetDuty(0, 0.5f); . | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#minimal-example",
    
    "relUrl": "/docs/quickstart/#minimal-example"
  },"131": {
    "doc": "‚ö° Quick Start",
    "title": "Step-by-Step Explanation",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#step-by-step-explanation",
    
    "relUrl": "/docs/quickstart/#step-by-step-explanation"
  },"132": {
    "doc": "‚ö° Quick Start",
    "title": "Step 1: Include the Header",
    "content": "| 1 . | #include \"pca9685.hpp\" . | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#step-1-include-the-header",
    
    "relUrl": "/docs/quickstart/#step-1-include-the-header"
  },"133": {
    "doc": "‚ö° Quick Start",
    "title": "Step 2: Implement the I2C Interface",
    "content": "You need to implement the I2cInterface for your platform. See Platform Integration for detailed examples for ESP32, STM32, and Arduino. The interface requires two methods: . | Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) - Write data to a register | Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) - Read data from a register | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#step-2-implement-the-i2c-interface",
    
    "relUrl": "/docs/quickstart/#step-2-implement-the-i2c-interface"
  },"134": {
    "doc": "‚ö° Quick Start",
    "title": "Step 3: Create Driver Instance",
    "content": "| 1 2 . | MyI2c i2c; pca9685::PCA9685&lt;MyI2c&gt; pwm(&amp;i2c, 0x40); . | . The constructor takes: . | Pointer to your I2C interface implementation | I2C address (0x40 is the default, can be changed via A0-A5 pins) | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#step-3-create-driver-instance",
    
    "relUrl": "/docs/quickstart/#step-3-create-driver-instance"
  },"135": {
    "doc": "‚ö° Quick Start",
    "title": "Step 4: Initialize",
    "content": "| 1 2 3 4 5 . | if (!pwm.Reset()) { // Handle initialization failure uint16_t flags = pwm.GetErrorFlags(); // Bitmask error flags auto error = pwm.GetLastError(); // Convenience accessor } . | . Reset() puts the device in a known state and must be called before other operations. ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#step-4-initialize",
    
    "relUrl": "/docs/quickstart/#step-4-initialize"
  },"136": {
    "doc": "‚ö° Quick Start",
    "title": "Step 5: Set PWM Frequency",
    "content": "| 1 . | pwm.SetPwmFreq(50.0f); // 50 Hz for servos . | . Important: You must set the frequency before setting channel outputs. Valid range is 24-1526 Hz. ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#step-5-set-pwm-frequency",
    
    "relUrl": "/docs/quickstart/#step-5-set-pwm-frequency"
  },"137": {
    "doc": "‚ö° Quick Start",
    "title": "Step 6: Control Channels",
    "content": "| 1 2 3 4 5 . | // Set duty cycle (0.0 = off, 1.0 = fully on) pwm.SetDuty(0, 0.5f); // Channel 0 at 50% // Or set precise timing pwm.SetPwm(1, 0, 2048); // Channel 1: on at 0, off at 2048 (50% duty) . | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#step-6-control-channels",
    
    "relUrl": "/docs/quickstart/#step-6-control-channels"
  },"138": {
    "doc": "‚ö° Quick Start",
    "title": "Expected Output",
    "content": "When running this example with a servo on channel 0: . | The servo should move to its center position (1.5ms pulse at 50 Hz) | No error messages should appear | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#expected-output",
    
    "relUrl": "/docs/quickstart/#expected-output"
  },"139": {
    "doc": "‚ö° Quick Start",
    "title": "Troubleshooting",
    "content": "If you encounter issues: . | Compilation errors: Check that you‚Äôve implemented all required I2C interface methods | Initialization fails: Verify hardware connections and I2C address | No output: Ensure SetPwmFreq() was called before setting channels | See: Troubleshooting for common issues | . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#troubleshooting",
    
    "relUrl": "/docs/quickstart/#troubleshooting"
  },"140": {
    "doc": "‚ö° Quick Start",
    "title": "Next Steps",
    "content": ". | Explore Examples for more advanced usage | Review the API Reference for all available methods | Check Configuration for customization options | . Navigation ‚¨ÖÔ∏è Installation | Next: Hardware Setup ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/#next-steps",
    
    "relUrl": "/docs/quickstart/#next-steps"
  },"141": {
    "doc": "‚ö° Quick Start",
    "title": "‚ö° Quick Start",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/quickstart/",
    
    "relUrl": "/docs/quickstart/"
  },"142": {
    "doc": "üêõ Troubleshooting",
    "title": "Troubleshooting",
    "content": "This guide helps you diagnose and resolve common issues when using the PCA9685 driver. ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#troubleshooting",
    
    "relUrl": "/docs/troubleshooting/#troubleshooting"
  },"143": {
    "doc": "üêõ Troubleshooting",
    "title": "Common Error Messages",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#common-error-messages",
    
    "relUrl": "/docs/troubleshooting/#common-error-messages"
  },"144": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Initialization Fails (Reset() returns false)",
    "content": "Symptoms: . | Reset() returns false | GetLastError() returns I2cWrite (or GetErrorFlags() has I2cWrite bit set) | . Causes: . | I2C bus not initialized | Wrong I2C address | Hardware connections incorrect | Pull-up resistors missing | . Solutions: . | Verify I2C bus initialization: | 1 2 3 . | // Ensure I2C is initialized before creating driver. // ESP32: use driver/i2c_master.h (e.g. i2c_new_master_bus) as in // examples/esp32/main/esp32_pca9685_bus.hpp ‚Äî or your platform's I2C init. | . | Check I2C address: . | Default is 0x40 (all A0-A5 pins to GND) | Use I2C scanner to verify device address | Update address in constructor if different | . | Verify hardware connections: . | Check SDA/SCL connections | Verify 4.7kŒ© pull-up resistors on SDA and SCL | Ensure power (3.3V or 5V) is connected | . | Test I2C interface: . | Verify your I2C interface implementation works with other devices | Check I2C bus speed (try 100 kHz if 400 kHz fails) | . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#error-initialization-fails-reset-returns-false",
    
    "relUrl": "/docs/troubleshooting/#error-initialization-fails-reset-returns-false"
  },"145": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Frequency Out of Range",
    "content": "Symptoms: . | SetPwmFreq() returns false | GetLastError() returns OutOfRange (or GetErrorFlags() has OutOfRange bit set) | . Causes: . | Frequency value outside valid range (24-1526 Hz) | . Solutions: . | 1 2 3 4 . | // Clamp frequency to valid range float freq = 2000.0f; // Too high freq = std::max(24.0f, std::min(1526.0f, freq)); pwm.SetPwmFreq(freq); . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#error-frequency-out-of-range",
    
    "relUrl": "/docs/troubleshooting/#error-frequency-out-of-range"
  },"146": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Channel Out of Range",
    "content": "Symptoms: . | SetPwm() or SetDuty() returns false | GetLastError() returns OutOfRange (or GetErrorFlags() has OutOfRange bit set) | . Causes: . | Channel number &gt;= 16 | PWM values &gt; 4095 | . Solutions: . | 1 2 3 4 5 6 7 8 9 . | // Validate channel number if (channel &lt; 16) { pwm.SetDuty(channel, 0.5f); } // Validate PWM values if (on_time &lt;= 4095 &amp;&amp; off_time &lt;= 4095) { pwm.SetPwm(channel, on_time, off_time); } . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#error-channel-out-of-range",
    
    "relUrl": "/docs/troubleshooting/#error-channel-out-of-range"
  },"147": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Not Initialized",
    "content": "Symptoms: . | Methods return false | GetLastError() returns NotInitialized (or GetErrorFlags() has NotInitialized bit set) | . Causes: . | Reset() not called before other operations | . Solutions: . | 1 2 3 . | // Always call Reset() first pwm.Reset(); pwm.SetPwmFreq(50.0f); // Now this will work . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#error-not-initialized",
    
    "relUrl": "/docs/troubleshooting/#error-not-initialized"
  },"148": {
    "doc": "üêõ Troubleshooting",
    "title": "Hardware Issues",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#hardware-issues",
    
    "relUrl": "/docs/troubleshooting/#hardware-issues"
  },"149": {
    "doc": "üêõ Troubleshooting",
    "title": "Device Not Detected",
    "content": "Symptoms: . | Initialization fails | No response from device | I2C scanner doesn‚Äôt find device | . Checklist: . | Verify power supply voltage (2.3V-5.5V) | Check all connections are secure | Verify pull-up resistors (4.7kŒ©) on SCL and SDA | Check I2C address configuration (A0-A5 pins) | Use I2C scanner to detect device address | Verify ground connection | Check for short circuits | . Debugging: . | Use oscilloscope/logic analyzer to verify I2C bus activity | Check for proper I2C start/stop conditions | Verify ACK/NACK responses | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#device-not-detected",
    
    "relUrl": "/docs/troubleshooting/#device-not-detected"
  },"150": {
    "doc": "üêõ Troubleshooting",
    "title": "Communication Errors",
    "content": "Symptoms: . | Timeout errors | NACK errors (I2C) | Intermittent failures | . Solutions: . | Check bus speed: | 1 2 . | // Reduce speed if using long wires (e.g. in Esp32Pca9685Bus::I2CConfig) config.frequency = 100000; // 100 kHz instead of 400 kHz . | . | Verify signal integrity: . | Check for noise on I2C lines | Ensure proper ground plane | Keep traces short (&lt; 10 cm) | . | Check bus termination: . | Verify pull-up resistors are correct value | Check for multiple pull-ups (should only be one set) | . | Verify power supply: . | Ensure 3.3V/5V is stable | Check for voltage drops under load | Add decoupling capacitor (100 nF) close to VDD pin | . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#communication-errors",
    
    "relUrl": "/docs/troubleshooting/#communication-errors"
  },"151": {
    "doc": "üêõ Troubleshooting",
    "title": "No Output on Channels",
    "content": "Symptoms: . | Driver initializes successfully | No PWM output on channels | Servos/LEDs don‚Äôt respond | . Checklist: . | Did you call SetPwmFreq() before setting channels? | Are channel values within valid range (0-4095)? | Is OE pin pulled LOW (or floating)? (OE HIGH disables outputs) | Are outputs connected correctly? | Check with oscilloscope/multimeter for PWM signal | . Solutions: . | 1 2 3 4 . | // Correct sequence pwm.Reset(); // 1. Initialize pwm.SetPwmFreq(50.0f); // 2. Set frequency (REQUIRED!) pwm.SetDuty(0, 0.5f); // 3. Now set channels . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#no-output-on-channels",
    
    "relUrl": "/docs/troubleshooting/#no-output-on-channels"
  },"152": {
    "doc": "üêõ Troubleshooting",
    "title": "Software Issues",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#software-issues",
    
    "relUrl": "/docs/troubleshooting/#software-issues"
  },"153": {
    "doc": "üêõ Troubleshooting",
    "title": "Compilation Errors",
    "content": "Error: ‚ÄúNo matching function‚Äù . Solution: . | Ensure you‚Äôve implemented all required I2cInterface methods | Check method signatures match exactly: | 1 2 3 . | bool EnsureInitialized() noexcept; bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept; bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) noexcept; . | . | . Error: ‚ÄúUndefined reference‚Äù . Solution: . | The driver is template-based: implementation is in pca9685.ipp, included by pca9685.hpp. Ensure both inc/ and src/ are on the include path so the header can find the .ipp file. No separate library needs to be linked. | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#compilation-errors",
    
    "relUrl": "/docs/troubleshooting/#compilation-errors"
  },"154": {
    "doc": "üêõ Troubleshooting",
    "title": "Runtime Errors",
    "content": "Initialization Fails . Checklist: . | I2C bus is properly initialized | Hardware connections are correct | I2C address matches hardware configuration | Pull-up resistors are present | . Unexpected Behavior . Checklist: . | Frequency is set before setting channels | Channel numbers are 0-15 | Duty cycle values are 0.0-1.0 | PWM values are 0-4095 | Error handling code checks return values | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#runtime-errors",
    
    "relUrl": "/docs/troubleshooting/#runtime-errors"
  },"155": {
    "doc": "üêõ Troubleshooting",
    "title": "Debugging Tips",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#debugging-tips",
    
    "relUrl": "/docs/troubleshooting/#debugging-tips"
  },"156": {
    "doc": "üêõ Troubleshooting",
    "title": "Enable Debug Output",
    "content": "Add debug prints to your I2C interface: . | 1 2 3 4 5 6 7 . | bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) noexcept { printf(\"I2C Write: addr=0x%02X, reg=0x%02X, len=%zu\\n\", addr, reg, len); // ... your implementation bool result = /* ... */; printf(\"I2C Write result: %s\\n\", result ? \"OK\" : \"FAIL\"); return result; } . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#enable-debug-output",
    
    "relUrl": "/docs/troubleshooting/#enable-debug-output"
  },"157": {
    "doc": "üêõ Troubleshooting",
    "title": "Use I2C Scanner",
    "content": "Scan the I2C bus to verify device detection: . | 1 2 3 4 5 6 7 8 . | void i2c_scanner() { for (uint8_t addr = 0x08; addr &lt; 0x78; addr++) { // Try to write to address if (/* device responds */) { printf(\"Device found at 0x%02X\\n\", addr); } } } . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#use-i2c-scanner",
    
    "relUrl": "/docs/troubleshooting/#use-i2c-scanner"
  },"158": {
    "doc": "üêõ Troubleshooting",
    "title": "Check Error Flags",
    "content": "Always check and log error flags. Errors are now uint16_t bitmask flags: . | 1 2 3 4 5 6 7 8 9 10 . | if (!pwm.SetPwmFreq(50.0f)) { // Preferred: use bitmask error flags uint16_t flags = pwm.GetErrorFlags(); printf(\"Error flags: 0x%04X\\n\", flags); pwm.ClearErrorFlags(flags); // Clear after handling // Or use convenience accessor auto error = pwm.GetLastError(); printf(\"Error: %d\\n\", static_cast&lt;int&gt;(error)); } . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#check-error-flags",
    
    "relUrl": "/docs/troubleshooting/#check-error-flags"
  },"159": {
    "doc": "üêõ Troubleshooting",
    "title": "Use Logic Analyzer",
    "content": "For I2C communication issues, a logic analyzer can help: . | Verify correct I2C protocol | Check for ACK/NACK responses | Identify timing issues | Debug address conflicts | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#use-logic-analyzer",
    
    "relUrl": "/docs/troubleshooting/#use-logic-analyzer"
  },"160": {
    "doc": "üêõ Troubleshooting",
    "title": "FAQ",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#faq",
    
    "relUrl": "/docs/troubleshooting/#faq"
  },"161": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: Why do I need to call SetPwmFreq() before setting channels?",
    "content": "A: The PCA9685 requires the prescale register to be set before PWM outputs work correctly. The driver enforces this by checking initialization state. Always call Reset() then SetPwmFreq() before setting channels. ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#q-why-do-i-need-to-call-setpwmfreq-before-setting-channels",
    
    "relUrl": "/docs/troubleshooting/#q-why-do-i-need-to-call-setpwmfreq-before-setting-channels"
  },"162": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: Can I change frequency after setting channels?",
    "content": "A: Yes, but it will affect all channels. Changing frequency updates the prescale register, which changes the PWM period for all 16 channels simultaneously. ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#q-can-i-change-frequency-after-setting-channels",
    
    "relUrl": "/docs/troubleshooting/#q-can-i-change-frequency-after-setting-channels"
  },"163": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: What‚Äôs the difference between SetPwm() and SetDuty()?",
    "content": "A: . | SetPwm() gives you precise control over on/off timing (0-4095 ticks each) | SetDuty() is a convenience method that sets duty cycle as a float (0.0-1.0), automatically calculating the off_time | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#q-whats-the-difference-between-setpwm-and-setduty",
    
    "relUrl": "/docs/troubleshooting/#q-whats-the-difference-between-setpwm-and-setduty"
  },"164": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: Can I use multiple PCA9685 devices?",
    "content": "A: Yes! Configure different I2C addresses via A0-A5 pins, then create separate driver instances: . | 1 2 . | pca9685::PCA9685&lt;MyI2c&gt; pwm1(&amp;i2c, 0x40); // First device pca9685::PCA9685&lt;MyI2c&gt; pwm2(&amp;i2c, 0x41); // Second device . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#q-can-i-use-multiple-pca9685-devices",
    
    "relUrl": "/docs/troubleshooting/#q-can-i-use-multiple-pca9685-devices"
  },"165": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: Why are my servos not moving?",
    "content": "A: Common causes: . | Frequency not set (must call SetPwmFreq(50.0f) first) | Duty cycle out of servo range (try 0.05-0.10) | Servo power supply insufficient | OE pin pulled HIGH (disables outputs) | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#q-why-are-my-servos-not-moving",
    
    "relUrl": "/docs/troubleshooting/#q-why-are-my-servos-not-moving"
  },"166": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: How do I control the OE (Output Enable) pin?",
    "content": "A: The driver doesn‚Äôt control OE. You must control it via your platform‚Äôs GPIO: . | 1 2 3 . | // Example: ESP32 gpio_set_direction(OE_PIN, GPIO_MODE_OUTPUT); gpio_set_level(OE_PIN, 0); // Enable outputs . | . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#q-how-do-i-control-the-oe-output-enable-pin",
    
    "relUrl": "/docs/troubleshooting/#q-how-do-i-control-the-oe-output-enable-pin"
  },"167": {
    "doc": "üêõ Troubleshooting",
    "title": "Getting More Help",
    "content": "If you‚Äôre still experiencing issues: . | Check the API Reference for method details | Review Examples for working code | Search existing issues on GitHub | Open a new issue with: . | Description of the problem | Steps to reproduce | Hardware setup details | Error messages/logs | I2C bus analyzer output (if available) | . | . Navigation ‚¨ÖÔ∏è Examples | Back to Index . ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/#getting-more-help",
    
    "relUrl": "/docs/troubleshooting/#getting-more-help"
  },"168": {
    "doc": "üêõ Troubleshooting",
    "title": "üêõ Troubleshooting",
    "content": " ",
    "url": "/hf-pca9685-driver/development/docs/troubleshooting/",
    
    "relUrl": "/docs/troubleshooting/"
  },"169": {
    "doc": "PCA9685 Comprehensive Test Suite",
    "title": "PCA9685 Comprehensive Test Suite",
    "content": "# PCA9685 Comprehensive Test Suite The **pca9685_comprehensive_test** application runs a full set of tests against the PCA9685 driver and hardware. Use it to verify wiring, I2C address, and all driver features. ## What It Tests ### Test Sections (12 tasks total) 1. **Initialization** - **i2c_bus_initialization**: I2C bus init (SDA/SCL, 100 kHz). - **driver_initialization**: Driver creation and `Reset()`. 2. **Frequency** - **pwm_frequency**: Set 50, 100, 200, 500, 1000 Hz; check invalid 10 Hz / 2000 Hz handling. 3. **PWM** - **channel_pwm**: Set 50% duty on each of the 16 channels. 4. **Duty cycle** - **duty_cycle**: Sweep duty on all channels; clamp test (negative / >1.0). - **all_channel_control**: `SetAllPwm`, `SetChannelFullOn`, `SetChannelFullOff` on all 16. - **prescale_readback**: Set frequency, read prescale, verify (50, 200, 1000, 24, 1526 Hz). - **sleep_wake**: `Sleep()` / `Wake()` and PWM after wake; 5 sleep/wake cycles. - **output_config**: `SetOutputInvert`, `SetOutputDriverMode` (totem-pole / open-drain). 5. **Error handling** - **error_handling**: Invalid channel (255), invalid PWM (5000), invalid frequency (5 Hz); `GetLastError`, `ClearError`, `HasAnyError`. 6. **Stress** - **stress_rapid_writes**: Many back-to-back `SetDuty` and `SetAllPwm` and frequency changes. - **stress_boundary_values**: Min/max/staggered PWM on all channels; FullOn to FullOff to PWM; 5 reset cycles. ### I2C bus scan If the first attempt to connect to the PCA9685 at the configured address fails, the app runs an **I2C bus scan** (all 0x08 to 0x77) and logs which addresses respond. Use this to confirm the device address and bus. ## Source and Configuration - **Source**: `main/pca9685_comprehensive_test.cpp` - **I2C bus**: `main/esp32_pca9685_bus.hpp` (default SDA=GPIO4, SCL=GPIO5, 100 kHz) - **Address**: `PCA9685_I2C_ADDRESS` (default **0x40**) - **Sections**: Enable/disable via `ENABLE_*_TESTS` defines at the top of the test file. ## Build and Run From `examples/esp32`: ```bash ./scripts/build_app.sh pca9685_comprehensive_test Debug ./scripts/flash_app.sh flash_monitor pca9685_comprehensive_test Debug ``` Expected: all 12 tests pass, summary shows **Total: 12, Passed: 12, Failed: 0**. GPIO14 is used as a progress indicator. ## Customization - **I2C pins**: Build with CMake override, e.g. `-DPCA9685_EXAMPLE_I2C_SDA_GPIO=8 -DPCA9685_EXAMPLE_I2C_SCL_GPIO=9` - **Address**: Change `PCA9685_I2C_ADDRESS` in the test file to match A0 to A5. - **Sections**: Set `ENABLE_*_TESTS` to `false` to skip a section. ## Relation to the API The test exercises the public API as in the main docs API reference: - Init: `EnsureInitialized()`, `Reset()`, `IsInitialized()` - Frequency: `SetPwmFreq()`, `GetPrescale()` - PWM: `SetPwm()`, `SetDuty()`, `SetAllPwm()`, `SetChannelFullOn()`, `SetChannelFullOff()` - Power: `Sleep()`, `Wake()` - Output: `SetOutputInvert()`, `SetOutputDriverMode()` - Errors: `GetLastError()`, `GetErrorFlags()`, `HasError()`, `HasAnyError()`, `ClearError()`, `ClearErrorFlags()` See `../../../docs/api_reference.md` for full method list. ",
    "url": "/hf-pca9685-driver/development/examples/esp32/docs/comprehensive-test.html",
    
    "relUrl": "/examples/esp32/docs/comprehensive-test.html"
  },"170": {
    "doc": "ESP32 PCA9685 Applications ‚Äî Documentation",
    "title": "ESP32 PCA9685 Applications ‚Äî Documentation",
    "content": "# ESP32 PCA9685 Applications ‚Äî Documentation This folder describes the ESP32 applications that use the PCA9685 driver: what they do, how to build and run them, and how they relate to the driver API. ## Overview | Document | Content |----------|---------| [Index (this file)](/hf-pca9685-driver/development/examples/esp32/docs/) | Overview and links | [Comprehensive Test](/hf-pca9685-driver/development/examples/esp32/docs/comprehensive-test.html) | Test suite: 12 tests, I2C scan, build/run | [Servo Demo](/hf-pca9685-driver/development/examples/esp32/docs/servo-demo.html) | 16-channel servo animations, timing, velocity limits | ## Driver Documentation For the driver itself (class, API, integration): - **Main docs**: [../../../docs/](../../../docs/) ‚Äî installation, quick start, hardware setup, platform integration, configuration, API reference, examples, troubleshooting. - **API reference**: [../../../docs/api_reference.md](/hf-pca9685-driver/development/docs/api_reference/) ‚Äî all public methods, types, and constants. - **Root README**: [../../../README.md](/hf-pca9685-driver/development/) ‚Äî project overview and quick start. ## Applications Summary | App | Purpose | When to use |-----|---------|-------------| **pca9685_comprehensive_test** | Validate driver and hardware | After wiring; CI; regression. | **pca9685_servo_demo** | Demo 16 servos with smooth animations | Showcase; reference for servo timing and velocity limiting. | ## Build and Flash (short) From `examples/esp32`: ```bash ./scripts/build_app.sh list ./scripts/build_app.sh pca9685_comprehensive_test Debug ./scripts/flash_app.sh flash_monitor pca9685_comprehensive_test Debug ``` See [../README.md](/hf-pca9685-driver/development/examples/esp32/) for prerequisites, pin override, and troubleshooting. ",
    "url": "/hf-pca9685-driver/development/examples/esp32/docs/",
    
    "relUrl": "/examples/esp32/docs/"
  },"171": {
    "doc": "PCA9685 Hobby Servo Demo",
    "title": "PCA9685 Hobby Servo Demo",
    "content": "# PCA9685 Hobby Servo Demo The **pca9685_servo_demo** application drives up to 16 hobby servos from the PCA9685 with standard 1000‚Äì2000 ¬µs pulse width, velocity-limited motion, and synchronized animations. ## Servo Timing (50 Hz) - **PWM frequency**: 50 Hz (20 ms period), standard for hobby servos. - **Pulse width**: 1000 ¬µs (‚âà0¬∞) to 2000 ¬µs (‚âà180¬∞). Center ‚âà1500 ¬µs (‚âà90¬∞). - **PCA9685**: 4096 ticks per period ‚Üí 1 tick ‚âà 4.88 ¬µs. - 1000 ¬µs ‚Üí 205 ticks, 1500 ¬µs ‚Üí 307 ticks, 2000 ¬µs ‚Üí 410 ticks. ## Velocity Limiting Servos cannot jump instantly. The demo tracks a **current position** per channel and moves toward a **target** at a bounded rate: - **Max step**: 6 ticks per 20 ms update (~260¬∞/s). - Full 0¬∞‚Üí180¬∞ sweep in ~0.68 s, safe for typical hobby servos. All moves are ramped from the current setpoint; no instantaneous jumps. ## Startup Sequence 1. **Home**: All channels are set to 1000 ¬µs (0¬∞); 2 s wait for servos to physically align. 2. **Center**: All ramp to 1500 ¬µs (90¬∞). 3. **Range check**: All sweep to 2000 ¬µs, then 1000 ¬µs, then back to 1500 ¬µs. 4. **Animations**: A fixed set of animations runs in a loop. ## Animations (in order, looping) | Name | Description |------------|-------------| **Wave** | Travelling sine wave across all 16 channels. | **Breathe**| All 16 channels pulsate in unison (0¬∞‚Üî180¬∞). | **Cascade**| Staggered sweep: each channel starts 200 ms after the previous. | **Mirror** | Left half mirrors right (butterfly). | **Converge** | Outer vs inner channels: converge/diverge. | **Knight Rider** | Single ‚Äúspotlight‚Äù sweeps back and forth with falloff. | **Walk** | Even/odd channels in anti-phase (gait). | **Organic**| Multi-frequency superimposed waves. | Between animations, all channels return to center (1500 ¬µs). ## Source and Configuration - **Source**: `main/pca9685_servo_demo.cpp` - **I2C**: Same as comprehensive test (default SDA=GPIO4, SCL=GPIO5; `Esp32Pca9685Bus`). - **Address**: **0x40** (change in source if needed). - **Channels**: 16 (OUT0‚ÄìOUT15). Connect servos to PCA9685 outputs; ensure separate power for servos if needed. ## Build and Run From `examples/esp32`: ```bash ./scripts/build_app.sh pca9685_servo_demo Debug ./scripts/flash_app.sh flash_monitor pca9685_servo_demo Debug ``` The demo runs indefinitely; exit the monitor with Ctrl+]. ## Using the Driver for Servos in Your Code 1. Set **50 Hz**: `pwm.SetPwmFreq(50.0f);` 2. Use **pulse width**, not raw duty 0‚Äì1: - 1000 ¬µs ‚Üí `SetPwm(ch, 0, 205)` (or use a helper that converts ¬µs to ticks). - The demo uses a `ServoController` class that converts 1000‚Äì2000 ¬µs to ticks and applies velocity limiting; you can reuse or adapt that logic. 3. Avoid commanding large instantaneous changes; step or ramp toward the target to match servo speed limits. ## Relation to the API The demo uses: - `SetPwmFreq(50.0f)` - `SetOutputDriverMode(true)` (totem-pole) - `SetPwm(channel, 0, off_ticks)` for each channel every 20 ms See [../../../docs/api_reference.md](/hf-pca9685-driver/development/docs/api_reference/) for full method descriptions. ",
    "url": "/hf-pca9685-driver/development/examples/esp32/docs/servo-demo.html",
    
    "relUrl": "/examples/esp32/docs/servo-demo.html"
  },"172": {
    "doc": "PCA9685 ESP32 Examples",
    "title": "PCA9685 ESP32 Examples",
    "content": "# PCA9685 ESP32 Examples This directory contains ESP32 applications for the **PCA9685** 16-channel 12-bit PWM driver. They use ESP-IDF and the shared build/flash scripts. ## Table of Contents - [Hardware Overview](#-hardware-overview) - [Pin Connections](#-pin-connections) - [Available Applications](#-available-applications) - [Building and Flashing](#-building-and-flashing) - [Configuration](#-configuration) - [Troubleshooting](#-troubleshooting) - [Documentation](#-documentation) --- ## Hardware Overview ### PCA9685 PWM Controller The PCA9685 is a 16-channel, 12-bit PWM controller (I¬≤C). It is used to drive LEDs, hobby servos, and other PWM loads. - **Channels**: 16 (OUT0‚ÄìOUT15) - **Resolution**: 12-bit (0‚Äì4095 per channel) - **Frequency**: 24 Hz‚Äì1526 Hz (e.g. 50 Hz for servos, 1 kHz for LEDs) - **I2C**: 7-bit address, default **0x40** (A0‚ÄìA5 all LOW) ### ESP32 Host The examples use: - **I2C**: Default SDA=GPIO4, SCL=GPIO5 (100 kHz for PCA9685). Same pattern as the HardFOC pcal9555/bno08x examples. - **Test indicator**: GPIO14 (e.g. comprehensive test progress). --- ## Pin Connections ### I2C Bus | PCA9685 Pin | ESP32 GPIO | Function | Notes |-------------|------------|-----------------|---------------------------| SDA | GPIO4 | I2C Data | 4.7 kŒ© pull-up to 3.3 V | SCL | GPIO5 | I2C Clock | 4.7 kŒ© pull-up to 3.3 V | VDD | 3.3 V | Power | 2.3 V‚Äì5.5 V | GND | GND | Ground | ### Address (A0‚ÄìA5) | A5‚ÄìA0 | I2C Address (7-bit) |-----------|----------------------| All GND | **0x40** (default) | A0=VDD | 0x41 | ‚Ä¶ | 0x40‚Äì0x7F | **Default in examples**: **0x40**. ### Optional - **OE (Output Enable)**: Active-low. Leave unconnected or tie to GND to enable outputs. - **OUT0‚ÄìOUT15**: Connect to LEDs (with series resistors), servos, or other PWM loads. --- ## Available Applications | Application | Description |---------------------------------|-------------| **pca9685_comprehensive_test** | Full driver test suite: I2C init, driver init, PWM frequency, channel PWM, duty cycle, all-channel and full-on/off, prescale readback, sleep/wake, output config, error handling, stress tests. **12 tests**; runs once then prints summary. | **pca9685_servo_demo** | 16-channel hobby servo demo: 1000‚Äì2000 ¬µs pulse, velocity-limited motion, synchronized animations (Wave, Breathe, Cascade, Mirror, Converge, Knight Rider, Walk, Organic). **Loops forever.** | Details: [docs/](docs/) (index, comprehensive test, servo demo). --- ## Building and Flashing ### Prerequisites - **ESP-IDF** (e.g. `release/v5.5`). Install and source `export.sh` as usual. - **Target**: Default in config is `esp32s3`; other targets (e.g. `esp32`, `esp32c6`) depend on `app_config.yml` and component `targets`. ### First-Time Setup ```bash cd examples/esp32 chmod +x scripts/*.sh ./scripts/setup_repo.sh ``` ### List Applications ```bash ./scripts/build_app.sh list ``` ### Build ```bash # Debug ./scripts/build_app.sh pca9685_comprehensive_test Debug ./scripts/build_app.sh pca9685_servo_demo Debug # Release ./scripts/build_app.sh pca9685_comprehensive_test Release ``` ### Flash and Monitor ```bash ./scripts/flash_app.sh flash_monitor pca9685_comprehensive_test Debug ./scripts/flash_app.sh flash_monitor pca9685_servo_demo Debug ``` ### Flash-Only / Monitor-Only ```bash ./scripts/flash_app.sh flash pca9685_comprehensive_test Debug ./scripts/flash_app.sh monitor ``` --- ## Configuration ### I2C Pins Default: **SDA=GPIO4**, **SCL=GPIO5**. To override (e.g. for ESP32-S3 with different pins): ```bash ./scripts/build_app.sh pca9685_comprehensive_test Debug -- \\ -DPCA9685_EXAMPLE_I2C_SDA_GPIO=8 -DPCA9685_EXAMPLE_I2C_SCL_GPIO=9 ``` ### I2C Address Default in code is **0x40**. To use another address, change `PCA9685_I2C_ADDRESS` in the app source (e.g. `main/pca9685_comprehensive_test.cpp` or `main/pca9685_servo_demo.cpp`) and match hardware (A0‚ÄìA5). ### Test Sections (Comprehensive Test) In `main/pca9685_comprehensive_test.cpp` you can enable/disable test sections: ```cpp static constexpr bool ENABLE_INITIALIZATION_TESTS = true; static constexpr bool ENABLE_FREQUENCY_TESTS = true; static constexpr bool ENABLE_PWM_TESTS = true; static constexpr bool ENABLE_DUTY_CYCLE_TESTS = true; static constexpr bool ENABLE_ERROR_HANDLING_TESTS = true; static constexpr bool ENABLE_STRESS_TESTS = true; ``` --- ## Troubleshooting ### I2C / Init Failures - Check SDA/SCL wiring and 4.7 kŒ© pull-ups to 3.3 V. - Confirm address (A0‚ÄìA5). Default 0x40 = all GND. - If connection fails, the comprehensive test runs an **I2C bus scan** and prints detected addresses. - Try 100 kHz: in `Esp32Pca9685Bus::I2CConfig`, `frequency = 100000`. ### Build Errors - Ensure ESP-IDF is sourced: `idf.py --version`. - Clean and rebuild: `./scripts/build_app.sh --clean pca9685_comprehensive_test Debug`. ### No PWM Output - Call `SetPwmFreq()` (e.g. 50 Hz) before setting channels. - Ensure OE is not driven HIGH (outputs disabled). More: [../../docs/troubleshooting.md](/hf-pca9685-driver/development/docs/troubleshooting/). --- ## Documentation - **Driver docs** (API, quick start, hardware, platform integration): [../../docs/](../../docs/) - **ESP32 app docs** (comprehensive test, servo demo): [docs/](docs/) - **API reference**: [../../docs/api_reference.md](/hf-pca9685-driver/development/docs/api_reference/) --- ## Quick Reference ```bash ./scripts/build_app.sh list ./scripts/build_app.sh pca9685_comprehensive_test Debug ./scripts/flash_app.sh flash_monitor pca9685_comprehensive_test Debug ./scripts/flash_app.sh flash_monitor pca9685_servo_demo Debug ``` ",
    "url": "/hf-pca9685-driver/development/examples/esp32/",
    
    "relUrl": "/examples/esp32/"
  }
}
